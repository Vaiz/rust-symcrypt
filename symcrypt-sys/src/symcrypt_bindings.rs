/* automatically generated by rust-bindgen 0.65.1 */

pub const SYMCRYPT_CODE_VERSION_API: u32 = 103;
pub const SYMCRYPT_CODE_VERSION_MINOR: u32 = 5;
pub const SYMCRYPT_CODE_VERSION_PATCH: u32 = 1;
pub const SYMCRYPT_MD5_RESULT_SIZE: u32 = 16;
pub const SYMCRYPT_SHA1_RESULT_SIZE: u32 = 20;
pub const SYMCRYPT_SHA256_RESULT_SIZE: u32 = 32;
pub const SYMCRYPT_SHA384_RESULT_SIZE: u32 = 48;
pub const SYMCRYPT_SHA512_RESULT_SIZE: u32 = 64;
pub const SYMCRYPT_SHA3_256_RESULT_SIZE: u32 = 32;
pub const SYMCRYPT_SHA3_384_RESULT_SIZE: u32 = 48;
pub const SYMCRYPT_SHA3_512_RESULT_SIZE: u32 = 64;
pub const SYMCRYPT_FLAG_ECKEY_ECDSA: u32 = 4096;
pub const SYMCRYPT_FLAG_ECKEY_ECDH: u32 = 8192;
pub const SYMCRYPT_FLAG_RSAKEY_SIGN: u32 = 4096;
pub const SYMCRYPT_FLAG_RSAKEY_ENCRYPT: u32 = 8192;
pub const SYMCRYPT_FLAG_RSA_PKCS1_NO_ASN1: u32 = 1;
pub const SYMCRYPT_FLAG_RSA_PKCS1_OPTIONAL_HASH_OID: u32 = 2;
pub const SYMCRYPT_ERROR_SYMCRYPT_NO_ERROR: SYMCRYPT_ERROR = 0;
pub const SYMCRYPT_ERROR_SYMCRYPT_UNUSED: SYMCRYPT_ERROR = 32768;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_KEY_SIZE: SYMCRYPT_ERROR = 32769;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_BLOCK_SIZE: SYMCRYPT_ERROR = 32770;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_DATA_SIZE: SYMCRYPT_ERROR = 32771;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_NONCE_SIZE: SYMCRYPT_ERROR = 32772;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_TAG_SIZE: SYMCRYPT_ERROR = 32773;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_ITERATION_COUNT: SYMCRYPT_ERROR = 32774;
pub const SYMCRYPT_ERROR_SYMCRYPT_AUTHENTICATION_FAILURE: SYMCRYPT_ERROR = 32775;
pub const SYMCRYPT_ERROR_SYMCRYPT_EXTERNAL_FAILURE: SYMCRYPT_ERROR = 32776;
pub const SYMCRYPT_ERROR_SYMCRYPT_FIPS_FAILURE: SYMCRYPT_ERROR = 32777;
pub const SYMCRYPT_ERROR_SYMCRYPT_HARDWARE_FAILURE: SYMCRYPT_ERROR = 32778;
pub const SYMCRYPT_ERROR_SYMCRYPT_NOT_IMPLEMENTED: SYMCRYPT_ERROR = 32779;
pub const SYMCRYPT_ERROR_SYMCRYPT_INVALID_BLOB: SYMCRYPT_ERROR = 32780;
pub const SYMCRYPT_ERROR_SYMCRYPT_BUFFER_TOO_SMALL: SYMCRYPT_ERROR = 32781;
pub const SYMCRYPT_ERROR_SYMCRYPT_INVALID_ARGUMENT: SYMCRYPT_ERROR = 32782;
pub const SYMCRYPT_ERROR_SYMCRYPT_MEMORY_ALLOCATION_FAILURE: SYMCRYPT_ERROR = 32783;
pub const SYMCRYPT_ERROR_SYMCRYPT_SIGNATURE_VERIFICATION_FAILURE: SYMCRYPT_ERROR = 32784;
pub const SYMCRYPT_ERROR_SYMCRYPT_INCOMPATIBLE_FORMAT: SYMCRYPT_ERROR = 32785;
pub const SYMCRYPT_ERROR_SYMCRYPT_VALUE_TOO_LARGE: SYMCRYPT_ERROR = 32786;
pub const SYMCRYPT_ERROR_SYMCRYPT_SESSION_REPLAY_FAILURE: SYMCRYPT_ERROR = 32787;
pub const SYMCRYPT_ERROR_SYMCRYPT_HBS_NO_OTS_KEYS_LEFT: SYMCRYPT_ERROR = 32788;
pub const SYMCRYPT_ERROR_SYMCRYPT_HBS_PUBLIC_ROOT_MISMATCH: SYMCRYPT_ERROR = 32789;
pub type SYMCRYPT_ERROR = ::std::os::raw::c_int;
pub const _SYMCRYPT_ECURVE_TYPE_SYMCRYPT_ECURVE_TYPE_NULL: _SYMCRYPT_ECURVE_TYPE = 0;
pub const _SYMCRYPT_ECURVE_TYPE_SYMCRYPT_ECURVE_TYPE_SHORT_WEIERSTRASS: _SYMCRYPT_ECURVE_TYPE = 1;
pub const _SYMCRYPT_ECURVE_TYPE_SYMCRYPT_ECURVE_TYPE_TWISTED_EDWARDS: _SYMCRYPT_ECURVE_TYPE = 2;
pub const _SYMCRYPT_ECURVE_TYPE_SYMCRYPT_ECURVE_TYPE_MONTGOMERY: _SYMCRYPT_ECURVE_TYPE = 3;
pub type _SYMCRYPT_ECURVE_TYPE = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_ECURVE_TYPE as SYMCRYPT_ECURVE_TYPE;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type BYTE = ::std::os::raw::c_uchar;
pub type UINT32 = ::std::os::raw::c_uint;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type SIZE_T = ULONG_PTR;
pub type PBYTE = *mut BYTE;
pub type PCBYTE = *const BYTE;
pub type PCUINT32 = *const UINT32;
pub type PUINT64 = *mut UINT64;
pub type PCUINT64 = *const UINT64;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type PCVOID = *const ::std::os::raw::c_void;
pub type BOOLEAN = BYTE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union __m128i {
    pub m128i_i8: [::std::os::raw::c_char; 16usize],
    pub m128i_i16: [::std::os::raw::c_short; 8usize],
    pub m128i_i32: [::std::os::raw::c_int; 4usize],
    pub m128i_i64: [::std::os::raw::c_longlong; 2usize],
    pub m128i_u8: [::std::os::raw::c_uchar; 16usize],
    pub m128i_u16: [::std::os::raw::c_ushort; 8usize],
    pub m128i_u32: [::std::os::raw::c_uint; 4usize],
    pub m128i_u64: [::std::os::raw::c_ulonglong; 2usize],
}
#[test]
fn bindgen_test_layout___m128i() {
    const UNINIT: ::std::mem::MaybeUninit<__m128i> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__m128i>(),
        16usize,
        concat!("Size of: ", stringify!(__m128i))
    );
    assert_eq!(
        ::std::mem::align_of::<__m128i>(),
        16usize,
        concat!("Alignment of ", stringify!(__m128i))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i_i8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__m128i),
            "::",
            stringify!(m128i_i8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i_i16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__m128i),
            "::",
            stringify!(m128i_i16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i_i32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__m128i),
            "::",
            stringify!(m128i_i32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i_i64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__m128i),
            "::",
            stringify!(m128i_i64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i_u8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__m128i),
            "::",
            stringify!(m128i_u8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i_u16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__m128i),
            "::",
            stringify!(m128i_u16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i_u32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__m128i),
            "::",
            stringify!(m128i_u32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i_u64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__m128i),
            "::",
            stringify!(m128i_u64)
        )
    );
}
impl Default for __m128i {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_BLOCKCIPHER = _SYMCRYPT_BLOCKCIPHER;
pub type PCSYMCRYPT_BLOCKCIPHER = *const SYMCRYPT_BLOCKCIPHER;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MD2_CHAINING_STATE {
    pub C: [BYTE; 16usize],
    pub X: [BYTE; 48usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MD2_CHAINING_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MD2_CHAINING_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MD2_CHAINING_STATE>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MD2_CHAINING_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MD2_CHAINING_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MD2_CHAINING_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).C) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD2_CHAINING_STATE),
            "::",
            stringify!(C)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).X) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD2_CHAINING_STATE),
            "::",
            stringify!(X)
        )
    );
}
impl Default for _SYMCRYPT_MD2_CHAINING_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_MD2_CHAINING_STATE = _SYMCRYPT_MD2_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MD2_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 16usize],
    pub chain: SYMCRYPT_MD2_CHAINING_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MD2_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MD2_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MD2_STATE>(),
        112usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MD2_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MD2_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MD2_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD2_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD2_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD2_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD2_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD2_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD2_STATE),
            "::",
            stringify!(chain)
        )
    );
}
impl Default for _SYMCRYPT_MD2_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_MD2_STATE = _SYMCRYPT_MD2_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_MD4_CHAINING_STATE {
    pub H: [UINT32; 4usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MD4_CHAINING_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MD4_CHAINING_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MD4_CHAINING_STATE>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MD4_CHAINING_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MD4_CHAINING_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MD4_CHAINING_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD4_CHAINING_STATE),
            "::",
            stringify!(H)
        )
    );
}
pub type SYMCRYPT_MD4_CHAINING_STATE = _SYMCRYPT_MD4_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MD4_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 64usize],
    pub chain: SYMCRYPT_MD4_CHAINING_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MD4_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MD4_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MD4_STATE>(),
        112usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MD4_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MD4_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MD4_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD4_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD4_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD4_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD4_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD4_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD4_STATE),
            "::",
            stringify!(chain)
        )
    );
}
impl Default for _SYMCRYPT_MD4_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_MD4_STATE = _SYMCRYPT_MD4_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_MD5_CHAINING_STATE {
    pub H: [UINT32; 4usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MD5_CHAINING_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MD5_CHAINING_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MD5_CHAINING_STATE>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MD5_CHAINING_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MD5_CHAINING_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MD5_CHAINING_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD5_CHAINING_STATE),
            "::",
            stringify!(H)
        )
    );
}
pub type SYMCRYPT_MD5_CHAINING_STATE = _SYMCRYPT_MD5_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MD5_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 64usize],
    pub chain: SYMCRYPT_MD5_CHAINING_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MD5_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MD5_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MD5_STATE>(),
        112usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MD5_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MD5_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MD5_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD5_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD5_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD5_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD5_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD5_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD5_STATE),
            "::",
            stringify!(chain)
        )
    );
}
impl Default for _SYMCRYPT_MD5_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_MD5_STATE = _SYMCRYPT_MD5_STATE;
pub type PSYMCRYPT_MD5_STATE = *mut _SYMCRYPT_MD5_STATE;
pub type PCSYMCRYPT_MD5_STATE = *const SYMCRYPT_MD5_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_SHA1_CHAINING_STATE {
    pub H: [UINT32; 5usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA1_CHAINING_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA1_CHAINING_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA1_CHAINING_STATE>(),
        32usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA1_CHAINING_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA1_CHAINING_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA1_CHAINING_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA1_CHAINING_STATE),
            "::",
            stringify!(H)
        )
    );
}
pub type SYMCRYPT_SHA1_CHAINING_STATE = _SYMCRYPT_SHA1_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_SHA1_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 64usize],
    pub chain: SYMCRYPT_SHA1_CHAINING_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA1_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA1_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA1_STATE>(),
        128usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA1_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA1_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA1_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA1_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA1_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA1_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA1_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA1_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA1_STATE),
            "::",
            stringify!(chain)
        )
    );
}
impl Default for _SYMCRYPT_SHA1_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SHA1_STATE = _SYMCRYPT_SHA1_STATE;
pub type PSYMCRYPT_SHA1_STATE = *mut _SYMCRYPT_SHA1_STATE;
pub type PCSYMCRYPT_SHA1_STATE = *const SYMCRYPT_SHA1_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_SHA256_CHAINING_STATE {
    pub H: [UINT32; 8usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA256_CHAINING_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA256_CHAINING_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA256_CHAINING_STATE>(),
        32usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA256_CHAINING_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA256_CHAINING_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA256_CHAINING_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_CHAINING_STATE),
            "::",
            stringify!(H)
        )
    );
}
pub type SYMCRYPT_SHA256_CHAINING_STATE = _SYMCRYPT_SHA256_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_SHA256_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 64usize],
    pub chain: SYMCRYPT_SHA256_CHAINING_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA256_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA256_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA256_STATE>(),
        128usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA256_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA256_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA256_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(chain)
        )
    );
}
impl Default for _SYMCRYPT_SHA256_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SHA256_STATE = _SYMCRYPT_SHA256_STATE;
pub type PSYMCRYPT_SHA256_STATE = *mut _SYMCRYPT_SHA256_STATE;
pub type PCSYMCRYPT_SHA256_STATE = *const SYMCRYPT_SHA256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_SHA512_CHAINING_STATE {
    pub H: [UINT64; 8usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA512_CHAINING_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA512_CHAINING_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA512_CHAINING_STATE>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA512_CHAINING_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA512_CHAINING_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA512_CHAINING_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA512_CHAINING_STATE),
            "::",
            stringify!(H)
        )
    );
}
pub type SYMCRYPT_SHA512_CHAINING_STATE = _SYMCRYPT_SHA512_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_SHA512_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 128usize],
    pub chain: SYMCRYPT_SHA512_CHAINING_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA512_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA512_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA512_STATE>(),
        224usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA512_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA512_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA512_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA512_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA512_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA512_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA512_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA512_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA512_STATE),
            "::",
            stringify!(chain)
        )
    );
}
impl Default for _SYMCRYPT_SHA512_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SHA512_STATE = _SYMCRYPT_SHA512_STATE;
pub type PSYMCRYPT_SHA512_STATE = *mut _SYMCRYPT_SHA512_STATE;
pub type PCSYMCRYPT_SHA512_STATE = *const SYMCRYPT_SHA512_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_SHA384_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 128usize],
    pub chain: SYMCRYPT_SHA512_CHAINING_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA384_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA384_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA384_STATE>(),
        224usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA384_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA384_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA384_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(chain)
        )
    );
}
impl Default for _SYMCRYPT_SHA384_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SHA384_STATE = _SYMCRYPT_SHA384_STATE;
pub type PSYMCRYPT_SHA384_STATE = *mut _SYMCRYPT_SHA384_STATE;
pub type PCSYMCRYPT_SHA384_STATE = *const SYMCRYPT_SHA384_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_KECCAK_STATE {
    pub state: [UINT64; 25usize],
    pub inputBlockSize: UINT32,
    pub stateIndex: UINT32,
    pub paddingValue: UINT8,
    pub squeezeMode: BOOLEAN,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_KECCAK_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_KECCAK_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_KECCAK_STATE>(),
        224usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_KECCAK_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_KECCAK_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_KECCAK_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_KECCAK_STATE),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputBlockSize) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_KECCAK_STATE),
            "::",
            stringify!(inputBlockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateIndex) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_KECCAK_STATE),
            "::",
            stringify!(stateIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paddingValue) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_KECCAK_STATE),
            "::",
            stringify!(paddingValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).squeezeMode) as usize - ptr as usize },
        209usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_KECCAK_STATE),
            "::",
            stringify!(squeezeMode)
        )
    );
}
pub type SYMCRYPT_KECCAK_STATE = _SYMCRYPT_KECCAK_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_SHA3_256_STATE {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA3_256_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA3_256_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA3_256_STATE>(),
        240usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA3_256_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA3_256_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA3_256_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA3_256_STATE),
            "::",
            stringify!(ks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA3_256_STATE),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_SHA3_256_STATE = _SYMCRYPT_SHA3_256_STATE;
pub type PSYMCRYPT_SHA3_256_STATE = *mut _SYMCRYPT_SHA3_256_STATE;
pub type PCSYMCRYPT_SHA3_256_STATE = *const SYMCRYPT_SHA3_256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_SHA3_384_STATE {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA3_384_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA3_384_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA3_384_STATE>(),
        240usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA3_384_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA3_384_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA3_384_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA3_384_STATE),
            "::",
            stringify!(ks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA3_384_STATE),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_SHA3_384_STATE = _SYMCRYPT_SHA3_384_STATE;
pub type PSYMCRYPT_SHA3_384_STATE = *mut _SYMCRYPT_SHA3_384_STATE;
pub type PCSYMCRYPT_SHA3_384_STATE = *const SYMCRYPT_SHA3_384_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_SHA3_512_STATE {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA3_512_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA3_512_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA3_512_STATE>(),
        240usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA3_512_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA3_512_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA3_512_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA3_512_STATE),
            "::",
            stringify!(ks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA3_512_STATE),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_SHA3_512_STATE = _SYMCRYPT_SHA3_512_STATE;
pub type PSYMCRYPT_SHA3_512_STATE = *mut _SYMCRYPT_SHA3_512_STATE;
pub type PCSYMCRYPT_SHA3_512_STATE = *const SYMCRYPT_SHA3_512_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_KMAC128_EXPANDED_KEY {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_KMAC128_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_KMAC128_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_KMAC128_EXPANDED_KEY>(),
        240usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_KMAC128_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_KMAC128_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_KMAC128_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_KMAC128_EXPANDED_KEY),
            "::",
            stringify!(ks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_KMAC128_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_KMAC128_EXPANDED_KEY = _SYMCRYPT_KMAC128_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_KMAC256_EXPANDED_KEY {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_KMAC256_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_KMAC256_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_KMAC256_EXPANDED_KEY>(),
        240usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_KMAC256_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_KMAC256_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_KMAC256_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_KMAC256_EXPANDED_KEY),
            "::",
            stringify!(ks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_KMAC256_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_KMAC256_EXPANDED_KEY = _SYMCRYPT_KMAC256_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_HASH_STATE {
    pub md2State: SYMCRYPT_MD2_STATE,
    pub md4State: SYMCRYPT_MD4_STATE,
    pub md5State: SYMCRYPT_MD5_STATE,
    pub sha1State: SYMCRYPT_SHA1_STATE,
    pub sha256State: SYMCRYPT_SHA256_STATE,
    pub sha384State: SYMCRYPT_SHA384_STATE,
    pub sha512State: SYMCRYPT_SHA512_STATE,
    pub sha3_256State: SYMCRYPT_SHA3_256_STATE,
    pub sha3_384State: SYMCRYPT_SHA3_384_STATE,
    pub sha3_512State: SYMCRYPT_SHA3_512_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HASH_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HASH_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HASH_STATE>(),
        240usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HASH_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HASH_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HASH_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md2State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(md2State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md4State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(md4State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md5State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(md5State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha1State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(sha1State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha256State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(sha256State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha384State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(sha384State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha512State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(sha512State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha3_256State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(sha3_256State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha3_384State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(sha3_384State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha3_512State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(sha3_512State)
        )
    );
}
impl Default for _SYMCRYPT_HASH_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HASH_STATE = _SYMCRYPT_HASH_STATE;
pub type SYMCRYPT_HASH = _SYMCRYPT_HASH;
pub type PCSYMCRYPT_HASH = *const SYMCRYPT_HASH;
pub type PSYMCRYPT_HASH_INIT_FUNC = ::std::option::Option<unsafe extern "C" fn(pState: PVOID)>;
pub type PSYMCRYPT_HASH_APPEND_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbData: PCBYTE, cbData: SIZE_T)>;
pub type PSYMCRYPT_HASH_RESULT_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbResult: PVOID)>;
pub type PSYMCRYPT_HASH_APPEND_BLOCKS_FUNC = ::std::option::Option<
    unsafe extern "C" fn(pChain: PVOID, pbData: PCBYTE, cbData: SIZE_T, pcbRemaining: *mut SIZE_T),
>;
pub type PSYMCRYPT_HASH_STATE_COPY_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pStateSrc: PCVOID, pStateDst: PVOID)>;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HASH {
    pub initFunc: PSYMCRYPT_HASH_INIT_FUNC,
    pub appendFunc: PSYMCRYPT_HASH_APPEND_FUNC,
    pub resultFunc: PSYMCRYPT_HASH_RESULT_FUNC,
    pub appendBlockFunc: PSYMCRYPT_HASH_APPEND_BLOCKS_FUNC,
    pub stateCopyFunc: PSYMCRYPT_HASH_STATE_COPY_FUNC,
    pub stateSize: UINT32,
    pub resultSize: UINT32,
    pub inputBlockSize: UINT32,
    pub chainOffset: UINT32,
    pub chainSize: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HASH() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HASH> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HASH>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HASH))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HASH>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HASH))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initFunc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(initFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appendFunc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(appendFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resultFunc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(resultFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appendBlockFunc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(appendBlockFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateCopyFunc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(stateCopyFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(stateSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resultSize) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(resultSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputBlockSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(inputBlockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chainOffset) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(chainOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chainSize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(chainSize)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_MD5_EXPANDED_KEY {
    pub innerState: SYMCRYPT_MD5_CHAINING_STATE,
    pub outerState: SYMCRYPT_MD5_CHAINING_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_MD5_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_MD5_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_MD5_EXPANDED_KEY>(),
        48usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_MD5_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_MD5_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HMAC_MD5_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).innerState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_MD5_EXPANDED_KEY),
            "::",
            stringify!(innerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerState) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_MD5_EXPANDED_KEY),
            "::",
            stringify!(outerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_MD5_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_MD5_EXPANDED_KEY = _SYMCRYPT_HMAC_MD5_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_MD5_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_MD5_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY = *const SYMCRYPT_HMAC_MD5_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_MD5_STATE {
    pub hash: SYMCRYPT_MD5_STATE,
    pub pKey: PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_MD5_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_MD5_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_MD5_STATE>(),
        128usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_MD5_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_MD5_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HMAC_MD5_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_MD5_STATE),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pKey) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_MD5_STATE),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_MD5_STATE),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_HMAC_MD5_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_MD5_STATE = _SYMCRYPT_HMAC_MD5_STATE;
pub type PSYMCRYPT_HMAC_MD5_STATE = *mut _SYMCRYPT_HMAC_MD5_STATE;
pub type PCSYMCRYPT_HMAC_MD5_STATE = *const SYMCRYPT_HMAC_MD5_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA1_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA1_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA1_CHAINING_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA1_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY>(),
        80usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).innerState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY),
            "::",
            stringify!(innerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerState) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY),
            "::",
            stringify!(outerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_SHA1_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA1_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA1_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA1_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA1_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA1_STATE {
    pub hash: SYMCRYPT_SHA1_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA1_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA1_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA1_STATE>(),
        144usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA1_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA1_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HMAC_SHA1_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA1_STATE),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pKey) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA1_STATE),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA1_STATE),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_HMAC_SHA1_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA1_STATE = _SYMCRYPT_HMAC_SHA1_STATE;
pub type PSYMCRYPT_HMAC_SHA1_STATE = *mut _SYMCRYPT_HMAC_SHA1_STATE;
pub type PCSYMCRYPT_HMAC_SHA1_STATE = *const SYMCRYPT_HMAC_SHA1_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA256_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA256_CHAINING_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA256_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY>(),
        80usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).innerState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY),
            "::",
            stringify!(innerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerState) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY),
            "::",
            stringify!(outerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_SHA256_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA256_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA256_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA256_STATE {
    pub hash: SYMCRYPT_SHA256_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA256_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA256_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA256_STATE>(),
        144usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA256_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA256_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HMAC_SHA256_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_STATE),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pKey) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_STATE),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_STATE),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_HMAC_SHA256_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA256_STATE = _SYMCRYPT_HMAC_SHA256_STATE;
pub type PSYMCRYPT_HMAC_SHA256_STATE = *mut _SYMCRYPT_HMAC_SHA256_STATE;
pub type PCSYMCRYPT_HMAC_SHA256_STATE = *const SYMCRYPT_HMAC_SHA256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA384_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY>(),
        144usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).innerState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY),
            "::",
            stringify!(innerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerState) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY),
            "::",
            stringify!(outerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_SHA384_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA384_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA384_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA384_STATE {
    pub hash: SYMCRYPT_SHA384_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA384_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA384_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA384_STATE>(),
        240usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA384_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA384_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HMAC_SHA384_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_STATE),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pKey) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_STATE),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_STATE),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_HMAC_SHA384_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA384_STATE = _SYMCRYPT_HMAC_SHA384_STATE;
pub type PSYMCRYPT_HMAC_SHA384_STATE = *mut _SYMCRYPT_HMAC_SHA384_STATE;
pub type PCSYMCRYPT_HMAC_SHA384_STATE = *const SYMCRYPT_HMAC_SHA384_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA512_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA512_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY>(),
        144usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).innerState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY),
            "::",
            stringify!(innerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerState) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY),
            "::",
            stringify!(outerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_SHA512_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA512_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA512_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA512_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA512_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA512_STATE {
    pub hash: SYMCRYPT_SHA512_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA512_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA512_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA512_STATE>(),
        240usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA512_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA512_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HMAC_SHA512_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA512_STATE),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pKey) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA512_STATE),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA512_STATE),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_HMAC_SHA512_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA512_STATE = _SYMCRYPT_HMAC_SHA512_STATE;
pub type PSYMCRYPT_HMAC_SHA512_STATE = *mut _SYMCRYPT_HMAC_SHA512_STATE;
pub type PCSYMCRYPT_HMAC_SHA512_STATE = *const SYMCRYPT_HMAC_SHA512_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HMAC_EXPANDED_KEY {
    pub pHash: PCSYMCRYPT_HASH,
    pub __bindgen_padding_0: u64,
    pub innerState: SYMCRYPT_HASH_STATE,
    pub outerState: SYMCRYPT_HASH_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_EXPANDED_KEY>(),
        512usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HMAC_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pHash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_EXPANDED_KEY),
            "::",
            stringify!(pHash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).innerState) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_EXPANDED_KEY),
            "::",
            stringify!(innerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerState) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_EXPANDED_KEY),
            "::",
            stringify!(outerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_HMAC_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_EXPANDED_KEY = _SYMCRYPT_HMAC_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY {
    pub generic: SYMCRYPT_HMAC_EXPANDED_KEY,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY>(),
        512usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).generic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY),
            "::",
            stringify!(generic)
        )
    );
}
impl Default for _SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY {
    pub generic: SYMCRYPT_HMAC_EXPANDED_KEY,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY>(),
        512usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).generic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY),
            "::",
            stringify!(generic)
        )
    );
}
impl Default for _SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY {
    pub generic: SYMCRYPT_HMAC_EXPANDED_KEY,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY>(),
        512usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).generic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY),
            "::",
            stringify!(generic)
        )
    );
}
impl Default for _SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_AES_EXPANDED_KEY {
    pub RoundKey: [[[BYTE; 4usize]; 4usize]; 29usize],
    pub lastEncRoundKey: *mut [[BYTE; 4usize]; 4usize],
    pub lastDecRoundKey: *mut [[BYTE; 4usize]; 4usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_AES_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_AES_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_AES_EXPANDED_KEY>(),
        496usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_AES_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_AES_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_AES_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoundKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_EXPANDED_KEY),
            "::",
            stringify!(RoundKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastEncRoundKey) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_EXPANDED_KEY),
            "::",
            stringify!(lastEncRoundKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastDecRoundKey) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_EXPANDED_KEY),
            "::",
            stringify!(lastDecRoundKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_AES_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_AES_EXPANDED_KEY = _SYMCRYPT_AES_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_AES_CMAC_EXPANDED_KEY {
    pub aesKey: SYMCRYPT_AES_EXPANDED_KEY,
    pub K1: [BYTE; 16usize],
    pub K2: [BYTE; 16usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_AES_CMAC_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_AES_CMAC_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_AES_CMAC_EXPANDED_KEY>(),
        544usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_AES_CMAC_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aesKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY),
            "::",
            stringify!(aesKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).K1) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY),
            "::",
            stringify!(K1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).K2) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY),
            "::",
            stringify!(K2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_AES_CMAC_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_AES_CMAC_EXPANDED_KEY = _SYMCRYPT_AES_CMAC_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_MAC_EXPANDED_KEY {
    pub md5Key: SYMCRYPT_HMAC_MD5_EXPANDED_KEY,
    pub sha1Key: SYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
    pub sha256Key: SYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
    pub sha384Key: SYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
    pub sha512Key: SYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
    pub sha3_256Key: SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY,
    pub sha3_384Key: SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY,
    pub sha3_512Key: SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY,
    pub aescmacKey: SYMCRYPT_AES_CMAC_EXPANDED_KEY,
    pub kmac128Key: SYMCRYPT_KMAC128_EXPANDED_KEY,
    pub kmac256Key: SYMCRYPT_KMAC256_EXPANDED_KEY,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MAC_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MAC_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MAC_EXPANDED_KEY>(),
        544usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MAC_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MAC_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MAC_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md5Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(md5Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha1Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(sha1Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha256Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(sha256Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha384Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(sha384Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha512Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(sha512Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha3_256Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(sha3_256Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha3_384Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(sha3_384Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha3_512Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(sha3_512Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aescmacKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(aescmacKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kmac128Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(kmac128Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).kmac256Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(kmac256Key)
        )
    );
}
impl Default for _SYMCRYPT_MAC_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_MAC_EXPANDED_KEY = _SYMCRYPT_MAC_EXPANDED_KEY;
pub type PSYMCRYPT_MAC_EXPAND_KEY = ::std::option::Option<
    unsafe extern "C" fn(pExpandedKey: PVOID, pbKey: PCBYTE, cbKey: SIZE_T) -> SYMCRYPT_ERROR,
>;
pub type PSYMCRYPT_MAC_INIT =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pExpandedKey: PCVOID)>;
pub type PSYMCRYPT_MAC_APPEND =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbData: PCBYTE, cbData: SIZE_T)>;
pub type PSYMCRYPT_MAC_RESULT =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbResult: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MAC {
    pub expandKeyFunc: PSYMCRYPT_MAC_EXPAND_KEY,
    pub initFunc: PSYMCRYPT_MAC_INIT,
    pub appendFunc: PSYMCRYPT_MAC_APPEND,
    pub resultFunc: PSYMCRYPT_MAC_RESULT,
    pub expandedKeySize: SIZE_T,
    pub stateSize: SIZE_T,
    pub resultSize: SIZE_T,
    pub ppHashAlgorithm: *const PCSYMCRYPT_HASH,
    pub outerChainingStateOffset: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MAC() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MAC> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MAC>(),
        72usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MAC))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MAC>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MAC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expandKeyFunc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(expandKeyFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initFunc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(initFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appendFunc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(appendFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resultFunc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(resultFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expandedKeySize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(expandedKeySize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(stateSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resultSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(resultSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppHashAlgorithm) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(ppHashAlgorithm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerChainingStateOffset) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(outerChainingStateOffset)
        )
    );
}
impl Default for _SYMCRYPT_MAC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_MAC = _SYMCRYPT_MAC;
pub type PCSYMCRYPT_MAC = *const SYMCRYPT_MAC;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS {
    pub aes: SYMCRYPT_AES_EXPANDED_KEY,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS>(),
        496usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS),
            "::",
            stringify!(aes)
        )
    );
}
impl Default for _SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS = _SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_GF128_ELEMENT {
    pub ull: [UINT64; 2usize],
    pub m128i: __m128i,
    pub ul: [UINT32; 4usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GF128_ELEMENT() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_GF128_ELEMENT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GF128_ELEMENT>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_GF128_ELEMENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GF128_ELEMENT>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_GF128_ELEMENT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ull) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GF128_ELEMENT),
            "::",
            stringify!(ull)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GF128_ELEMENT),
            "::",
            stringify!(m128i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ul) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GF128_ELEMENT),
            "::",
            stringify!(ul)
        )
    );
}
impl Default for _SYMCRYPT_GF128_ELEMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_GF128_ELEMENT = _SYMCRYPT_GF128_ELEMENT;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_GHASH_EXPANDED_KEY {
    pub table: [SYMCRYPT_GF128_ELEMENT; 128usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GHASH_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_GHASH_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GHASH_EXPANDED_KEY>(),
        2048usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_GHASH_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GHASH_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_GHASH_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).table) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GHASH_EXPANDED_KEY),
            "::",
            stringify!(table)
        )
    );
}
impl Default for _SYMCRYPT_GHASH_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_GHASH_EXPANDED_KEY = _SYMCRYPT_GHASH_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_GCM_EXPANDED_KEY {
    pub ghashKey: SYMCRYPT_GHASH_EXPANDED_KEY,
    pub pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
    pub __bindgen_padding_0: u64,
    pub blockcipherKey: SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS,
    pub cbKey: SIZE_T,
    pub abKey: [BYTE; 32usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GCM_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_GCM_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GCM_EXPANDED_KEY>(),
        2608usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_GCM_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GCM_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_GCM_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ghashKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(ghashKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pBlockCipher) as usize - ptr as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(pBlockCipher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockcipherKey) as usize - ptr as usize },
        2064usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(blockcipherKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbKey) as usize - ptr as usize },
        2560usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(cbKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abKey) as usize - ptr as usize },
        2568usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(abKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        2600usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_GCM_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_GCM_EXPANDED_KEY = _SYMCRYPT_GCM_EXPANDED_KEY;
pub type PSYMCRYPT_GCM_EXPANDED_KEY = *mut _SYMCRYPT_GCM_EXPANDED_KEY;
pub type PCSYMCRYPT_GCM_EXPANDED_KEY = *const SYMCRYPT_GCM_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_GCM_STATE {
    pub pKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
    pub cbData: UINT64,
    pub cbAuthData: UINT64,
    pub bytesInMacBlock: SIZE_T,
    pub ghashState: SYMCRYPT_GF128_ELEMENT,
    pub counterBlock: [BYTE; 16usize],
    pub macBlock: [BYTE; 16usize],
    pub keystreamBlock: [BYTE; 16usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GCM_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_GCM_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GCM_STATE>(),
        112usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_GCM_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GCM_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_GCM_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(cbData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbAuthData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(cbAuthData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInMacBlock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(bytesInMacBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ghashState) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(ghashState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counterBlock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(counterBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macBlock) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(macBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keystreamBlock) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(keystreamBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_GCM_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_GCM_STATE = _SYMCRYPT_GCM_STATE;
pub type PSYMCRYPT_GCM_STATE = *mut _SYMCRYPT_GCM_STATE;
pub type PCSYMCRYPT_GCM_STATE = *const SYMCRYPT_GCM_STATE;
pub type PSYMCRYPT_BLOCKCIPHER_EXPAND_KEY = ::std::option::Option<
    unsafe extern "C" fn(pExpandedKey: PVOID, pbKey: PCBYTE, cbKey: SIZE_T) -> SYMCRYPT_ERROR,
>;
pub type PSYMCRYPT_BLOCKCIPHER_CRYPT =
    ::std::option::Option<unsafe extern "C" fn(pExpandedKey: PCVOID, pbSrc: PCBYTE, pbDst: PBYTE)>;
pub type PSYMCRYPT_BLOCKCIPHER_CRYPT_ECB = ::std::option::Option<
    unsafe extern "C" fn(pExpandedKey: PCVOID, pbSrc: PCBYTE, pbDst: PBYTE, cbData: SIZE_T),
>;
pub type PSYMCRYPT_BLOCKCIPHER_CRYPT_MODE = ::std::option::Option<
    unsafe extern "C" fn(
        pExpandedKey: PCVOID,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    ),
>;
pub type PSYMCRYPT_BLOCKCIPHER_MAC_MODE = ::std::option::Option<
    unsafe extern "C" fn(
        pExpandedKey: PCVOID,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        cbData: SIZE_T,
    ),
>;
pub type PSYMCRYPT_BLOCKCIPHER_AEADPART_MODE = ::std::option::Option<
    unsafe extern "C" fn(pState: PVOID, pbSrc: PCBYTE, pbDst: PBYTE, cbData: SIZE_T),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_BLOCKCIPHER {
    pub expandKeyFunc: PSYMCRYPT_BLOCKCIPHER_EXPAND_KEY,
    pub encryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT,
    pub decryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT,
    pub ecbEncryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT_ECB,
    pub ecbDecryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT_ECB,
    pub cbcEncryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT_MODE,
    pub cbcDecryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT_MODE,
    pub cbcMacFunc: PSYMCRYPT_BLOCKCIPHER_MAC_MODE,
    pub ctrMsb64Func: PSYMCRYPT_BLOCKCIPHER_CRYPT_MODE,
    pub gcmEncryptPartFunc: PSYMCRYPT_BLOCKCIPHER_AEADPART_MODE,
    pub gcmDecryptPartFunc: PSYMCRYPT_BLOCKCIPHER_AEADPART_MODE,
    pub blockSize: SIZE_T,
    pub expandedKeySize: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_BLOCKCIPHER() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_BLOCKCIPHER> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_BLOCKCIPHER>(),
        104usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_BLOCKCIPHER))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_BLOCKCIPHER>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_BLOCKCIPHER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expandKeyFunc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(expandKeyFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encryptFunc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(encryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decryptFunc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(decryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecbEncryptFunc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(ecbEncryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecbDecryptFunc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(ecbDecryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbcEncryptFunc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(cbcEncryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbcDecryptFunc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(cbcDecryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbcMacFunc) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(cbcMacFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctrMsb64Func) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(ctrMsb64Func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gcmEncryptPartFunc) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(gcmEncryptPartFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gcmDecryptPartFunc) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(gcmDecryptPartFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockSize) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(blockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expandedKeySize) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(expandedKeySize)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY {
    pub macKey: SYMCRYPT_MAC_EXPANDED_KEY,
    pub macAlg: PCSYMCRYPT_MAC,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_TLSPRF1_2_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY>(),
        560usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY),
            "::",
            stringify!(macKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macAlg) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY),
            "::",
            stringify!(macAlg)
        )
    );
}
impl Default for _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_TLSPRF1_2_EXPANDED_KEY = _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY;
pub type PSYMCRYPT_TLSPRF1_2_EXPANDED_KEY = *mut _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY;
pub type PCSYMCRYPT_TLSPRF1_2_EXPANDED_KEY = *const SYMCRYPT_TLSPRF1_2_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HKDF_EXPANDED_KEY {
    pub macKey: SYMCRYPT_MAC_EXPANDED_KEY,
    pub macAlg: PCSYMCRYPT_MAC,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HKDF_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HKDF_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HKDF_EXPANDED_KEY>(),
        560usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HKDF_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HKDF_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HKDF_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HKDF_EXPANDED_KEY),
            "::",
            stringify!(macKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macAlg) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HKDF_EXPANDED_KEY),
            "::",
            stringify!(macAlg)
        )
    );
}
impl Default for _SYMCRYPT_HKDF_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HKDF_EXPANDED_KEY = _SYMCRYPT_HKDF_EXPANDED_KEY;
pub type PSYMCRYPT_HKDF_EXPANDED_KEY = *mut _SYMCRYPT_HKDF_EXPANDED_KEY;
pub type PCSYMCRYPT_HKDF_EXPANDED_KEY = *const SYMCRYPT_HKDF_EXPANDED_KEY;
pub type SYMCRYPT_INT = _SYMCRYPT_INT;
pub type PSYMCRYPT_INT = *mut SYMCRYPT_INT;
pub type SYMCRYPT_DIVISOR = _SYMCRYPT_DIVISOR;
pub type SYMCRYPT_MODULUS = _SYMCRYPT_MODULUS;
pub type PSYMCRYPT_MODULUS = *mut SYMCRYPT_MODULUS;
pub type SYMCRYPT_MODELEMENT = _SYMCRYPT_MODELEMENT;
pub type PSYMCRYPT_MODELEMENT = *mut SYMCRYPT_MODELEMENT;
pub type SYMCRYPT_ECPOINT = _SYMCRYPT_ECPOINT;
pub type PSYMCRYPT_ECPOINT = *mut SYMCRYPT_ECPOINT;
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_INT {
    pub type_: UINT32,
    pub nDigits: UINT32,
    pub cbSize: UINT32,
    pub magic: SIZE_T,
    pub __bindgen_padding_0: u64,
    pub ti: _SYMCRYPT_INT__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_INT__bindgen_ty_1 {
    pub fdef: _SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1 {
    pub uint32: [UINT32; 1usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uint32)
        )
    );
}
#[test]
fn bindgen_test_layout__SYMCRYPT_INT__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_INT__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_INT__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_INT__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_INT__bindgen_ty_1>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_INT__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fdef) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT__bindgen_ty_1),
            "::",
            stringify!(fdef)
        )
    );
}
impl Default for _SYMCRYPT_INT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__SYMCRYPT_INT() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_INT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_INT>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_INT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_INT>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_INT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDigits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT),
            "::",
            stringify!(nDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT),
            "::",
            stringify!(cbSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ti) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT),
            "::",
            stringify!(ti)
        )
    );
}
impl Default for _SYMCRYPT_INT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_DIVISOR {
    pub type_: UINT32,
    pub nDigits: UINT32,
    pub cbSize: UINT32,
    pub nBits: UINT32,
    pub magic: SIZE_T,
    pub td: _SYMCRYPT_DIVISOR__bindgen_ty_1,
    pub Int: SYMCRYPT_INT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_DIVISOR__bindgen_ty_1 {
    pub fdef: _SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1 {
    pub W: UINT64,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(W)
        )
    );
}
#[test]
fn bindgen_test_layout__SYMCRYPT_DIVISOR__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_DIVISOR__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_DIVISOR__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_DIVISOR__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fdef) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1),
            "::",
            stringify!(fdef)
        )
    );
}
impl Default for _SYMCRYPT_DIVISOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__SYMCRYPT_DIVISOR() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_DIVISOR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_DIVISOR>(),
        96usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_DIVISOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_DIVISOR>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_DIVISOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDigits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(nDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(cbSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBits) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(nBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).td) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(td)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Int) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(Int)
        )
    );
}
impl Default for _SYMCRYPT_DIVISOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_MODULUS {
    pub type_: UINT32,
    pub nDigits: UINT32,
    pub cbSize: UINT32,
    pub flags: UINT32,
    pub cbModElement: UINT32,
    pub inv64: UINT64,
    pub magic: SIZE_T,
    pub tm: _SYMCRYPT_MODULUS__bindgen_ty_1,
    pub __bindgen_padding_0: [u64; 2usize],
    pub Divisor: SYMCRYPT_DIVISOR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_MODULUS__bindgen_ty_1 {
    pub montgomery: _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1,
    pub pseudoMersenne: _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1 {
    pub Rsqr: PCUINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rsqr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Rsqr)
        )
    );
}
impl Default for _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2 {
    pub k: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(k)
        )
    );
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODULUS__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODULUS__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODULUS__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODULUS__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).montgomery) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1),
            "::",
            stringify!(montgomery)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pseudoMersenne) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1),
            "::",
            stringify!(pseudoMersenne)
        )
    );
}
impl Default for _SYMCRYPT_MODULUS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODULUS() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODULUS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODULUS>(),
        160usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MODULUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODULUS>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MODULUS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDigits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(nDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(cbSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbModElement) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(cbModElement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inv64) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(inv64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(tm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Divisor) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(Divisor)
        )
    );
}
impl Default for _SYMCRYPT_MODULUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_MODELEMENT {
    pub d: _SYMCRYPT_MODELEMENT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_MODELEMENT__bindgen_ty_1 {
    pub uint32: [UINT32; 1usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODELEMENT__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODELEMENT__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODELEMENT__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MODELEMENT__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODELEMENT__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_MODELEMENT__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODELEMENT__bindgen_ty_1),
            "::",
            stringify!(uint32)
        )
    );
}
impl Default for _SYMCRYPT_MODELEMENT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODELEMENT() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODELEMENT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODELEMENT>(),
        32usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MODELEMENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODELEMENT>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MODELEMENT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODELEMENT),
            "::",
            stringify!(d)
        )
    );
}
impl Default for _SYMCRYPT_MODELEMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_RSAKEY {
    pub fAlgorithmInfo: UINT32,
    pub cbTotalSize: UINT32,
    pub hasPrivateKey: BOOLEAN,
    pub nSetBitsOfModulus: UINT32,
    pub nBitsOfModulus: UINT32,
    pub nDigitsOfModulus: UINT32,
    pub nPubExp: UINT32,
    pub nPrimes: UINT32,
    pub nBitsOfPrimes: [UINT32; 2usize],
    pub nDigitsOfPrimes: [UINT32; 2usize],
    pub nMaxDigitsOfPrimes: UINT32,
    pub au64PubExp: [UINT64; 1usize],
    pub pbPrimes: [PBYTE; 2usize],
    pub pbCrtInverses: [PBYTE; 2usize],
    pub pbPrivExps: [PBYTE; 1usize],
    pub pbCrtPrivExps: [PBYTE; 2usize],
    pub pmModulus: PSYMCRYPT_MODULUS,
    pub pmPrimes: [PSYMCRYPT_MODULUS; 2usize],
    pub peCrtInverses: [PSYMCRYPT_MODELEMENT; 2usize],
    pub piPrivExps: [PSYMCRYPT_INT; 1usize],
    pub piCrtPrivExps: [PSYMCRYPT_INT; 2usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_RSAKEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_RSAKEY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_RSAKEY>(),
        192usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_RSAKEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_RSAKEY>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_RSAKEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAlgorithmInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(fAlgorithmInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbTotalSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(cbTotalSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hasPrivateKey) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(hasPrivateKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nSetBitsOfModulus) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(nSetBitsOfModulus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBitsOfModulus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(nBitsOfModulus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDigitsOfModulus) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(nDigitsOfModulus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nPubExp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(nPubExp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nPrimes) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(nPrimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBitsOfPrimes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(nBitsOfPrimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDigitsOfPrimes) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(nDigitsOfPrimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nMaxDigitsOfPrimes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(nMaxDigitsOfPrimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).au64PubExp) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(au64PubExp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbPrimes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(pbPrimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbCrtInverses) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(pbCrtInverses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbPrivExps) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(pbPrivExps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbCrtPrivExps) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(pbCrtPrivExps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pmModulus) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(pmModulus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pmPrimes) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(pmPrimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).peCrtInverses) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(peCrtInverses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piPrivExps) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(piPrivExps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piCrtPrivExps) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(piCrtPrivExps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_RSAKEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_RSAKEY = _SYMCRYPT_RSAKEY;
pub type PSYMCRYPT_RSAKEY = *mut SYMCRYPT_RSAKEY;
pub type PCSYMCRYPT_RSAKEY = *const SYMCRYPT_RSAKEY;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_INVALID:
    _SYMCRYPT_ECPOINT_COORDINATES = 0;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_SINGLE:
    _SYMCRYPT_ECPOINT_COORDINATES = 17;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_AFFINE:
    _SYMCRYPT_ECPOINT_COORDINATES = 34;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_PROJECTIVE:
    _SYMCRYPT_ECPOINT_COORDINATES = 51;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_JACOBIAN:
    _SYMCRYPT_ECPOINT_COORDINATES = 67;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_EXTENDED_PROJECTIVE:
    _SYMCRYPT_ECPOINT_COORDINATES = 84;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_SINGLE_PROJECTIVE:
    _SYMCRYPT_ECPOINT_COORDINATES = 98;
pub type _SYMCRYPT_ECPOINT_COORDINATES = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_ECPOINT_COORDINATES as SYMCRYPT_ECPOINT_COORDINATES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_ECURVE_INFO_PRECOMP {
    pub window: UINT32,
    pub nPrecompPoints: UINT32,
    pub nRecodedDigits: UINT32,
    pub poPrecompPoints: [PSYMCRYPT_ECPOINT; 64usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE_INFO_PRECOMP() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECURVE_INFO_PRECOMP> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE_INFO_PRECOMP>(),
        528usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE_INFO_PRECOMP>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nPrecompPoints) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP),
            "::",
            stringify!(nPrecompPoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nRecodedDigits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP),
            "::",
            stringify!(nRecodedDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poPrecompPoints) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP),
            "::",
            stringify!(poPrecompPoints)
        )
    );
}
impl Default for _SYMCRYPT_ECURVE_INFO_PRECOMP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_ECURVE_INFO_PRECOMP = _SYMCRYPT_ECURVE_INFO_PRECOMP;
pub const _SYMCRYPT_INTERNAL_ECURVE_TYPE_SYMCRYPT_INTERNAL_ECURVE_TYPE_SHORT_WEIERSTRASS:
    _SYMCRYPT_INTERNAL_ECURVE_TYPE = 1;
pub const _SYMCRYPT_INTERNAL_ECURVE_TYPE_SYMCRYPT_INTERNAL_ECURVE_TYPE_TWISTED_EDWARDS:
    _SYMCRYPT_INTERNAL_ECURVE_TYPE = 2;
pub const _SYMCRYPT_INTERNAL_ECURVE_TYPE_SYMCRYPT_INTERNAL_ECURVE_TYPE_MONTGOMERY:
    _SYMCRYPT_INTERNAL_ECURVE_TYPE = 3;
pub const _SYMCRYPT_INTERNAL_ECURVE_TYPE_SYMCRYPT_INTERNAL_ECURVE_TYPE_SHORT_WEIERSTRASS_AM3:
    _SYMCRYPT_INTERNAL_ECURVE_TYPE = 4;
pub type _SYMCRYPT_INTERNAL_ECURVE_TYPE = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_INTERNAL_ECURVE_TYPE as SYMCRYPT_INTERNAL_ECURVE_TYPE;
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_ECURVE {
    pub version: UINT32,
    pub type_: SYMCRYPT_INTERNAL_ECURVE_TYPE,
    pub eCoordinates: SYMCRYPT_ECPOINT_COORDINATES,
    pub FModBitsize: UINT32,
    pub FModDigits: UINT32,
    pub FModBytesize: UINT32,
    pub GOrdBitsize: UINT32,
    pub GOrdDigits: UINT32,
    pub GOrdBytesize: UINT32,
    pub cbModElement: UINT32,
    pub cbAlloc: UINT32,
    pub cbScratchCommon: UINT32,
    pub cbScratchScalar: UINT32,
    pub cbScratchScalarMulti: UINT32,
    pub cbScratchGetSetValue: UINT32,
    pub cbScratchEckey: UINT32,
    pub coFactorPower: UINT32,
    pub PrivateKeyDefaultFormat: UINT32,
    pub HighBitRestrictionNumOfBits: UINT32,
    pub HighBitRestrictionPosition: UINT32,
    pub HighBitRestrictionValue: UINT32,
    pub info: _SYMCRYPT_ECURVE__bindgen_ty_1,
    pub FMod: PSYMCRYPT_MODULUS,
    pub GOrd: PSYMCRYPT_MODULUS,
    pub A: PSYMCRYPT_MODELEMENT,
    pub B: PSYMCRYPT_MODELEMENT,
    pub G: PSYMCRYPT_ECPOINT,
    pub H: PSYMCRYPT_INT,
    pub magic: SIZE_T,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_ECURVE__bindgen_ty_1 {
    pub sw: SYMCRYPT_ECURVE_INFO_PRECOMP,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECURVE__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE__bindgen_ty_1>(),
        528usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECURVE__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECURVE__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE__bindgen_ty_1),
            "::",
            stringify!(sw)
        )
    );
}
impl Default for _SYMCRYPT_ECURVE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECURVE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE>(),
        672usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECURVE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECURVE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eCoordinates) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(eCoordinates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FModBitsize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(FModBitsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FModDigits) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(FModDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FModBytesize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(FModBytesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GOrdBitsize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(GOrdBitsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GOrdDigits) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(GOrdDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GOrdBytesize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(GOrdBytesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbModElement) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbModElement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbAlloc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbAlloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbScratchCommon) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbScratchCommon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbScratchScalar) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbScratchScalar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbScratchScalarMulti) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbScratchScalarMulti)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbScratchGetSetValue) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbScratchGetSetValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbScratchEckey) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbScratchEckey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coFactorPower) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(coFactorPower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrivateKeyDefaultFormat) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(PrivateKeyDefaultFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighBitRestrictionNumOfBits) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(HighBitRestrictionNumOfBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighBitRestrictionPosition) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(HighBitRestrictionPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighBitRestrictionValue) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(HighBitRestrictionValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FMod) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(FMod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GOrd) as usize - ptr as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(GOrd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).A) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(A)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).B) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(B)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).G) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(G)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(H)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_ECURVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_ECURVE = _SYMCRYPT_ECURVE;
pub type PSYMCRYPT_ECURVE = *mut SYMCRYPT_ECURVE;
pub type PCSYMCRYPT_ECURVE = *const SYMCRYPT_ECURVE;
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_ECPOINT {
    pub normalized: BOOLEAN,
    pub pCurve: PCSYMCRYPT_ECURVE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECPOINT() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECPOINT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECPOINT>(),
        32usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECPOINT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECPOINT>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECPOINT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).normalized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECPOINT),
            "::",
            stringify!(normalized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCurve) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECPOINT),
            "::",
            stringify!(pCurve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECPOINT),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_ECPOINT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_ECKEY {
    pub fAlgorithmInfo: UINT32,
    pub hasPrivateKey: BOOLEAN,
    pub pCurve: PCSYMCRYPT_ECURVE,
    pub poPublicKey: PSYMCRYPT_ECPOINT,
    pub piPrivateKey: PSYMCRYPT_INT,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECKEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECKEY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECKEY>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECKEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECKEY>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECKEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAlgorithmInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(fAlgorithmInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hasPrivateKey) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(hasPrivateKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCurve) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(pCurve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poPublicKey) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(poPublicKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piPrivateKey) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(piPrivateKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(magic)
        )
    );
}
impl Default for _SYMCRYPT_ECKEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_ECKEY = _SYMCRYPT_ECKEY;
pub type PSYMCRYPT_ECKEY = *mut SYMCRYPT_ECKEY;
pub type PCSYMCRYPT_ECKEY = *const SYMCRYPT_ECKEY;
extern "C" {
    pub static SymCryptMd5Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub static SymCryptSha1Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub static SymCryptSha256Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub static SymCryptSha384Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub static SymCryptSha512Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub static SymCryptSha3_256Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub static SymCryptSha3_384Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub static SymCryptSha3_512Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub static SymCryptAesBlockCipher: PCSYMCRYPT_BLOCKCIPHER;
}
pub const _SYMCRYPT_NUMBER_FORMAT_SYMCRYPT_NUMBER_FORMAT_LSB_FIRST: _SYMCRYPT_NUMBER_FORMAT = 1;
pub const _SYMCRYPT_NUMBER_FORMAT_SYMCRYPT_NUMBER_FORMAT_MSB_FIRST: _SYMCRYPT_NUMBER_FORMAT = 2;
pub type _SYMCRYPT_NUMBER_FORMAT = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_NUMBER_FORMAT as SYMCRYPT_NUMBER_FORMAT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SYMCRYPT_RSA_PARAMS {
    pub version: UINT32,
    pub nBitsOfModulus: UINT32,
    pub nPrimes: UINT32,
    pub nPubExp: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_RSA_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_RSA_PARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_RSA_PARAMS>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_RSA_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_RSA_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_RSA_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSA_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBitsOfModulus) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSA_PARAMS),
            "::",
            stringify!(nBitsOfModulus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nPrimes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSA_PARAMS),
            "::",
            stringify!(nPrimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nPubExp) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSA_PARAMS),
            "::",
            stringify!(nPubExp)
        )
    );
}
pub type SYMCRYPT_RSA_PARAMS = _SYMCRYPT_RSA_PARAMS;
pub type PCSYMCRYPT_RSA_PARAMS = *const SYMCRYPT_RSA_PARAMS;
pub const _SYMCRYPT_ECURVE_GEN_ALG_ID_SYMCRYPT_ECURVE_GEN_ALG_ID_NULL: _SYMCRYPT_ECURVE_GEN_ALG_ID =
    0;
pub type _SYMCRYPT_ECURVE_GEN_ALG_ID = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_ECURVE_GEN_ALG_ID as SYMCRYPT_ECURVE_GEN_ALG_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_ECURVE_PARAMS {
    pub version: UINT32,
    pub type_: SYMCRYPT_ECURVE_TYPE,
    pub algId: SYMCRYPT_ECURVE_GEN_ALG_ID,
    pub cbFieldLength: UINT32,
    pub cbSubgroupOrder: UINT32,
    pub cbCofactor: UINT32,
    pub cbSeed: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECURVE_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE_PARAMS>(),
        28usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECURVE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECURVE_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).algId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(algId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbFieldLength) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(cbFieldLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSubgroupOrder) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(cbSubgroupOrder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbCofactor) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(cbCofactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSeed) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(cbSeed)
        )
    );
}
impl Default for _SYMCRYPT_ECURVE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_ECURVE_PARAMS = _SYMCRYPT_ECURVE_PARAMS;
pub type PCSYMCRYPT_ECURVE_PARAMS = *const SYMCRYPT_ECURVE_PARAMS;
pub const _SYMCRYPT_ECPOINT_FORMAT_SYMCRYPT_ECPOINT_FORMAT_X: _SYMCRYPT_ECPOINT_FORMAT = 1;
pub const _SYMCRYPT_ECPOINT_FORMAT_SYMCRYPT_ECPOINT_FORMAT_XY: _SYMCRYPT_ECPOINT_FORMAT = 2;
pub type _SYMCRYPT_ECPOINT_FORMAT = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_ECPOINT_FORMAT as SYMCRYPT_ECPOINT_FORMAT;
extern "C" {
    pub static SymCryptEcurveParamsNistP256: PCSYMCRYPT_ECURVE_PARAMS;
}
extern "C" {
    pub static SymCryptEcurveParamsNistP384: PCSYMCRYPT_ECURVE_PARAMS;
}
extern "C" {
    pub static SymCryptEcurveParamsCurve25519: PCSYMCRYPT_ECURVE_PARAMS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_OID {
    pub cbOID: UINT32,
    pub pbOID: PCBYTE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_OID() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_OID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_OID>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_OID))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_OID>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_OID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbOID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_OID),
            "::",
            stringify!(cbOID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbOID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_OID),
            "::",
            stringify!(pbOID)
        )
    );
}
impl Default for _SYMCRYPT_OID {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_OID = _SYMCRYPT_OID;
pub type PCSYMCRYPT_OID = *const SYMCRYPT_OID;
extern "C" {
    pub static SymCryptMd5OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha1OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha256OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha384OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha512OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha3_256OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha3_384OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha3_512OidList: [SYMCRYPT_OID; 2usize];
}
extern crate libloading;
pub struct symcrypt {
    __library: ::libloading::Library,
    pub SymCryptWipe:
        Result<unsafe extern "C" fn(pbData: PVOID, cbData: SIZE_T), ::libloading::Error>,
    pub SymCryptLoadMsbFirstUint64: Result<
        unsafe extern "C" fn(pbSrc: PCBYTE, cbSrc: SIZE_T, pDst: PUINT64) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptStoreMsbFirstUint64: Result<
        unsafe extern "C" fn(src: UINT64, pbDst: PBYTE, cbDst: SIZE_T) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptModuleInit:
        Result<unsafe extern "C" fn(api: UINT32, minor: UINT32), ::libloading::Error>,
    pub SymCryptMd5: Result<
        unsafe extern "C" fn(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptMd5Init:
        Result<unsafe extern "C" fn(pState: PSYMCRYPT_MD5_STATE), ::libloading::Error>,
    pub SymCryptMd5Append: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_MD5_STATE, pbData: PCBYTE, cbData: SIZE_T),
        ::libloading::Error,
    >,
    pub SymCryptMd5Result: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_MD5_STATE, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptMd5StateCopy: Result<
        unsafe extern "C" fn(pSrc: PCSYMCRYPT_MD5_STATE, pDst: PSYMCRYPT_MD5_STATE),
        ::libloading::Error,
    >,
    pub SymCryptSha1: Result<
        unsafe extern "C" fn(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptSha1Init:
        Result<unsafe extern "C" fn(pState: PSYMCRYPT_SHA1_STATE), ::libloading::Error>,
    pub SymCryptSha1Append: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_SHA1_STATE, pbData: PCBYTE, cbData: SIZE_T),
        ::libloading::Error,
    >,
    pub SymCryptSha1Result: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_SHA1_STATE, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptSha1StateCopy: Result<
        unsafe extern "C" fn(pSrc: PCSYMCRYPT_SHA1_STATE, pDst: PSYMCRYPT_SHA1_STATE),
        ::libloading::Error,
    >,
    pub SymCryptSha256: Result<
        unsafe extern "C" fn(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptSha256Init:
        Result<unsafe extern "C" fn(pState: PSYMCRYPT_SHA256_STATE), ::libloading::Error>,
    pub SymCryptSha256Append: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_SHA256_STATE, pbData: PCBYTE, cbData: SIZE_T),
        ::libloading::Error,
    >,
    pub SymCryptSha256Result: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_SHA256_STATE, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptSha256StateCopy: Result<
        unsafe extern "C" fn(pSrc: PCSYMCRYPT_SHA256_STATE, pDst: PSYMCRYPT_SHA256_STATE),
        ::libloading::Error,
    >,
    pub SymCryptSha384: Result<
        unsafe extern "C" fn(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptSha384Init:
        Result<unsafe extern "C" fn(pState: PSYMCRYPT_SHA384_STATE), ::libloading::Error>,
    pub SymCryptSha384Append: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_SHA384_STATE, pbData: PCBYTE, cbData: SIZE_T),
        ::libloading::Error,
    >,
    pub SymCryptSha384Result: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_SHA384_STATE, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptSha384StateCopy: Result<
        unsafe extern "C" fn(pSrc: PCSYMCRYPT_SHA384_STATE, pDst: PSYMCRYPT_SHA384_STATE),
        ::libloading::Error,
    >,
    pub SymCryptSha512: Result<
        unsafe extern "C" fn(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptSha512Init:
        Result<unsafe extern "C" fn(pState: PSYMCRYPT_SHA512_STATE), ::libloading::Error>,
    pub SymCryptSha512Append: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_SHA512_STATE, pbData: PCBYTE, cbData: SIZE_T),
        ::libloading::Error,
    >,
    pub SymCryptSha512Result: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_SHA512_STATE, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptSha512StateCopy: Result<
        unsafe extern "C" fn(pSrc: PCSYMCRYPT_SHA512_STATE, pDst: PSYMCRYPT_SHA512_STATE),
        ::libloading::Error,
    >,
    pub SymCryptSha3_256: Result<
        unsafe extern "C" fn(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptSha3_256Init:
        Result<unsafe extern "C" fn(pState: PSYMCRYPT_SHA3_256_STATE), ::libloading::Error>,
    pub SymCryptSha3_256Append: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_SHA3_256_STATE, pbData: PCBYTE, cbData: SIZE_T),
        ::libloading::Error,
    >,
    pub SymCryptSha3_256Result: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_SHA3_256_STATE, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptSha3_256StateCopy: Result<
        unsafe extern "C" fn(pSrc: PCSYMCRYPT_SHA3_256_STATE, pDst: PSYMCRYPT_SHA3_256_STATE),
        ::libloading::Error,
    >,
    pub SymCryptSha3_384: Result<
        unsafe extern "C" fn(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptSha3_384Init:
        Result<unsafe extern "C" fn(pState: PSYMCRYPT_SHA3_384_STATE), ::libloading::Error>,
    pub SymCryptSha3_384Append: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_SHA3_384_STATE, pbData: PCBYTE, cbData: SIZE_T),
        ::libloading::Error,
    >,
    pub SymCryptSha3_384Result: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_SHA3_384_STATE, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptSha3_384StateCopy: Result<
        unsafe extern "C" fn(pSrc: PCSYMCRYPT_SHA3_384_STATE, pDst: PSYMCRYPT_SHA3_384_STATE),
        ::libloading::Error,
    >,
    pub SymCryptSha3_512: Result<
        unsafe extern "C" fn(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptSha3_512Init:
        Result<unsafe extern "C" fn(pState: PSYMCRYPT_SHA3_512_STATE), ::libloading::Error>,
    pub SymCryptSha3_512Append: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_SHA3_512_STATE, pbData: PCBYTE, cbData: SIZE_T),
        ::libloading::Error,
    >,
    pub SymCryptSha3_512Result: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_SHA3_512_STATE, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptSha3_512StateCopy: Result<
        unsafe extern "C" fn(pSrc: PCSYMCRYPT_SHA3_512_STATE, pDst: PSYMCRYPT_SHA3_512_STATE),
        ::libloading::Error,
    >,
    pub SymCryptHmacMd5ExpandKey: Result<
        unsafe extern "C" fn(
            pExpandedKey: PSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
            pbKey: PCBYTE,
            cbKey: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptHmacMd5: Result<
        unsafe extern "C" fn(
            pExpandedKey: PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
            pbData: PCBYTE,
            cbData: SIZE_T,
            pbResult: PBYTE,
        ),
        ::libloading::Error,
    >,
    pub SymCryptHmacMd5StateCopy: Result<
        unsafe extern "C" fn(
            pSrc: PCSYMCRYPT_HMAC_MD5_STATE,
            pExpandedKey: PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
            pDst: PSYMCRYPT_HMAC_MD5_STATE,
        ),
        ::libloading::Error,
    >,
    pub SymCryptHmacMd5Init: Result<
        unsafe extern "C" fn(
            pState: PSYMCRYPT_HMAC_MD5_STATE,
            pExpandedKey: PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
        ),
        ::libloading::Error,
    >,
    pub SymCryptHmacMd5Append: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_HMAC_MD5_STATE, pbData: PCBYTE, cbData: SIZE_T),
        ::libloading::Error,
    >,
    pub SymCryptHmacMd5Result: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_HMAC_MD5_STATE, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha1ExpandKey: Result<
        unsafe extern "C" fn(
            pExpandedKey: PSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
            pbKey: PCBYTE,
            cbKey: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptHmacSha1: Result<
        unsafe extern "C" fn(
            pExpandedKey: PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
            pbData: PCBYTE,
            cbData: SIZE_T,
            pbResult: PBYTE,
        ),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha1StateCopy: Result<
        unsafe extern "C" fn(
            pSrc: PCSYMCRYPT_HMAC_SHA1_STATE,
            pExpandedKey: PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
            pDst: PSYMCRYPT_HMAC_SHA1_STATE,
        ),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha1Init: Result<
        unsafe extern "C" fn(
            pState: PSYMCRYPT_HMAC_SHA1_STATE,
            pExpandedKey: PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
        ),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha1Append: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_HMAC_SHA1_STATE, pbData: PCBYTE, cbData: SIZE_T),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha1Result: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_HMAC_SHA1_STATE, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha256ExpandKey: Result<
        unsafe extern "C" fn(
            pExpandedKey: PSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
            pbKey: PCBYTE,
            cbKey: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptHmacSha256: Result<
        unsafe extern "C" fn(
            pExpandedKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
            pbData: PCBYTE,
            cbData: SIZE_T,
            pbResult: PBYTE,
        ),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha256StateCopy: Result<
        unsafe extern "C" fn(
            pSrc: PCSYMCRYPT_HMAC_SHA256_STATE,
            pExpandedKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
            pDst: PSYMCRYPT_HMAC_SHA256_STATE,
        ),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha256Init: Result<
        unsafe extern "C" fn(
            pState: PSYMCRYPT_HMAC_SHA256_STATE,
            pExpandedKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
        ),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha256Append: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_HMAC_SHA256_STATE, pbData: PCBYTE, cbData: SIZE_T),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha256Result: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_HMAC_SHA256_STATE, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha384ExpandKey: Result<
        unsafe extern "C" fn(
            pExpandedKey: PSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
            pbKey: PCBYTE,
            cbKey: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptHmacSha384: Result<
        unsafe extern "C" fn(
            pExpandedKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
            pbData: PCBYTE,
            cbData: SIZE_T,
            pbResult: PBYTE,
        ),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha384StateCopy: Result<
        unsafe extern "C" fn(
            pSrc: PCSYMCRYPT_HMAC_SHA384_STATE,
            pExpandedKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
            pDst: PSYMCRYPT_HMAC_SHA384_STATE,
        ),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha384Init: Result<
        unsafe extern "C" fn(
            pState: PSYMCRYPT_HMAC_SHA384_STATE,
            pExpandedKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
        ),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha384Append: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_HMAC_SHA384_STATE, pbData: PCBYTE, cbData: SIZE_T),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha384Result: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_HMAC_SHA384_STATE, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha512ExpandKey: Result<
        unsafe extern "C" fn(
            pExpandedKey: PSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
            pbKey: PCBYTE,
            cbKey: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptHmacSha512: Result<
        unsafe extern "C" fn(
            pExpandedKey: PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
            pbData: PCBYTE,
            cbData: SIZE_T,
            pbResult: PBYTE,
        ),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha512StateCopy: Result<
        unsafe extern "C" fn(
            pSrc: PCSYMCRYPT_HMAC_SHA512_STATE,
            pExpandedKey: PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
            pDst: PSYMCRYPT_HMAC_SHA512_STATE,
        ),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha512Init: Result<
        unsafe extern "C" fn(
            pState: PSYMCRYPT_HMAC_SHA512_STATE,
            pExpandedKey: PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
        ),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha512Append: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_HMAC_SHA512_STATE, pbData: PCBYTE, cbData: SIZE_T),
        ::libloading::Error,
    >,
    pub SymCryptHmacSha512Result: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_HMAC_SHA512_STATE, pbResult: PBYTE),
        ::libloading::Error,
    >,
    pub SymCryptChaCha20Poly1305Encrypt: Result<
        unsafe extern "C" fn(
            pbKey: PCBYTE,
            cbKey: SIZE_T,
            pbNonce: PCBYTE,
            cbNonce: SIZE_T,
            pbAuthData: PCBYTE,
            cbAuthData: SIZE_T,
            pbSrc: PCBYTE,
            pbDst: PBYTE,
            cbData: SIZE_T,
            pbTag: PBYTE,
            cbTag: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptChaCha20Poly1305Decrypt: Result<
        unsafe extern "C" fn(
            pbKey: PCBYTE,
            cbKey: SIZE_T,
            pbNonce: PCBYTE,
            cbNonce: SIZE_T,
            pbAuthData: PCBYTE,
            cbAuthData: SIZE_T,
            pbSrc: PCBYTE,
            pbDst: PBYTE,
            cbData: SIZE_T,
            pbTag: PCBYTE,
            cbTag: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptGcmValidateParameters: Result<
        unsafe extern "C" fn(
            pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
            cbNonce: SIZE_T,
            cbAssociatedData: UINT64,
            cbData: UINT64,
            cbTag: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptGcmExpandKey: Result<
        unsafe extern "C" fn(
            pExpandedKey: PSYMCRYPT_GCM_EXPANDED_KEY,
            pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
            pbKey: PCBYTE,
            cbKey: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptGcmEncrypt: Result<
        unsafe extern "C" fn(
            pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
            pbNonce: PCBYTE,
            cbNonce: SIZE_T,
            pbAuthData: PCBYTE,
            cbAuthData: SIZE_T,
            pbSrc: PCBYTE,
            pbDst: PBYTE,
            cbData: SIZE_T,
            pbTag: PBYTE,
            cbTag: SIZE_T,
        ),
        ::libloading::Error,
    >,
    pub SymCryptGcmDecrypt: Result<
        unsafe extern "C" fn(
            pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
            pbNonce: PCBYTE,
            cbNonce: SIZE_T,
            pbAuthData: PCBYTE,
            cbAuthData: SIZE_T,
            pbSrc: PCBYTE,
            pbDst: PBYTE,
            cbData: SIZE_T,
            pbTag: PCBYTE,
            cbTag: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptGcmInit: Result<
        unsafe extern "C" fn(
            pState: PSYMCRYPT_GCM_STATE,
            pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
            pbNonce: PCBYTE,
            cbNonce: SIZE_T,
        ),
        ::libloading::Error,
    >,
    pub SymCryptGcmStateCopy: Result<
        unsafe extern "C" fn(
            pSrc: PCSYMCRYPT_GCM_STATE,
            pExpandedKeyCopy: PCSYMCRYPT_GCM_EXPANDED_KEY,
            pDst: PSYMCRYPT_GCM_STATE,
        ),
        ::libloading::Error,
    >,
    pub SymCryptGcmAuthPart: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_GCM_STATE, pbAuthData: PCBYTE, cbData: SIZE_T),
        ::libloading::Error,
    >,
    pub SymCryptGcmEncryptPart: Result<
        unsafe extern "C" fn(
            pState: PSYMCRYPT_GCM_STATE,
            pbSrc: PCBYTE,
            pbDst: PBYTE,
            cbData: SIZE_T,
        ),
        ::libloading::Error,
    >,
    pub SymCryptGcmEncryptFinal: Result<
        unsafe extern "C" fn(pState: PSYMCRYPT_GCM_STATE, pbTag: PBYTE, cbTag: SIZE_T),
        ::libloading::Error,
    >,
    pub SymCryptGcmDecryptPart: Result<
        unsafe extern "C" fn(
            pState: PSYMCRYPT_GCM_STATE,
            pbSrc: PCBYTE,
            pbDst: PBYTE,
            cbData: SIZE_T,
        ),
        ::libloading::Error,
    >,
    pub SymCryptGcmDecryptFinal: Result<
        unsafe extern "C" fn(
            pState: PSYMCRYPT_GCM_STATE,
            pbTag: PCBYTE,
            cbTag: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptTlsPrf1_2ExpandKey: Result<
        unsafe extern "C" fn(
            pExpandedKey: PSYMCRYPT_TLSPRF1_2_EXPANDED_KEY,
            macAlgorithm: PCSYMCRYPT_MAC,
            pbKey: PCBYTE,
            cbKey: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptTlsPrf1_2Derive: Result<
        unsafe extern "C" fn(
            pExpandedKey: PCSYMCRYPT_TLSPRF1_2_EXPANDED_KEY,
            pbLabel: PCBYTE,
            cbLabel: SIZE_T,
            pbSeed: PCBYTE,
            cbSeed: SIZE_T,
            pbResult: PBYTE,
            cbResult: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptTlsPrf1_2: Result<
        unsafe extern "C" fn(
            macAlgorithm: PCSYMCRYPT_MAC,
            pbKey: PCBYTE,
            cbKey: SIZE_T,
            pbLabel: PCBYTE,
            cbLabel: SIZE_T,
            pbSeed: PCBYTE,
            cbSeed: SIZE_T,
            pbResult: PBYTE,
            cbResult: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptHkdfExpandKey: Result<
        unsafe extern "C" fn(
            pExpandedKey: PSYMCRYPT_HKDF_EXPANDED_KEY,
            macAlgorithm: PCSYMCRYPT_MAC,
            pbIkm: PCBYTE,
            cbIkm: SIZE_T,
            pbSalt: PCBYTE,
            cbSalt: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptHkdfExtractPrk: Result<
        unsafe extern "C" fn(
            macAlgorithm: PCSYMCRYPT_MAC,
            pbIkm: PCBYTE,
            cbIkm: SIZE_T,
            pbSalt: PCBYTE,
            cbSalt: SIZE_T,
            pbPrk: PBYTE,
            cbPrk: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptHkdfPrkExpandKey: Result<
        unsafe extern "C" fn(
            pExpandedKey: PSYMCRYPT_HKDF_EXPANDED_KEY,
            macAlgorithm: PCSYMCRYPT_MAC,
            pbPrk: PCBYTE,
            cbPrk: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptHkdfDerive: Result<
        unsafe extern "C" fn(
            pExpandedKey: PCSYMCRYPT_HKDF_EXPANDED_KEY,
            pbInfo: PCBYTE,
            cbInfo: SIZE_T,
            pbResult: PBYTE,
            cbResult: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptHkdf: Result<
        unsafe extern "C" fn(
            macAlgorithm: PCSYMCRYPT_MAC,
            pbIkm: PCBYTE,
            cbIkm: SIZE_T,
            pbSalt: PCBYTE,
            cbSalt: SIZE_T,
            pbInfo: PCBYTE,
            cbInfo: SIZE_T,
            pbResult: PBYTE,
            cbResult: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptHkdfSelfTest: Result<unsafe extern "C" fn(), ::libloading::Error>,
    pub SymCryptRandom:
        Result<unsafe extern "C" fn(pbRandom: PBYTE, cbRandom: SIZE_T), ::libloading::Error>,
    pub SymCryptRsakeyAllocate: Result<
        unsafe extern "C" fn(pParams: PCSYMCRYPT_RSA_PARAMS, flags: UINT32) -> PSYMCRYPT_RSAKEY,
        ::libloading::Error,
    >,
    pub SymCryptRsakeyFree:
        Result<unsafe extern "C" fn(pkObj: PSYMCRYPT_RSAKEY), ::libloading::Error>,
    pub SymCryptEcurveAllocate: Result<
        unsafe extern "C" fn(pParams: PCSYMCRYPT_ECURVE_PARAMS, flags: UINT32) -> PSYMCRYPT_ECURVE,
        ::libloading::Error,
    >,
    pub SymCryptEcurveFree:
        Result<unsafe extern "C" fn(pCurve: PSYMCRYPT_ECURVE), ::libloading::Error>,
    pub SymCryptEckeyAllocate: Result<
        unsafe extern "C" fn(pCurve: PCSYMCRYPT_ECURVE) -> PSYMCRYPT_ECKEY,
        ::libloading::Error,
    >,
    pub SymCryptEckeyFree:
        Result<unsafe extern "C" fn(pkObj: PSYMCRYPT_ECKEY), ::libloading::Error>,
    pub SymCryptRsakeyHasPrivateKey:
        Result<unsafe extern "C" fn(pkRsakey: PCSYMCRYPT_RSAKEY) -> BOOLEAN, ::libloading::Error>,
    pub SymCryptRsakeySizeofModulus:
        Result<unsafe extern "C" fn(pkRsakey: PCSYMCRYPT_RSAKEY) -> UINT32, ::libloading::Error>,
    pub SymCryptRsakeyModulusBits:
        Result<unsafe extern "C" fn(pkRsakey: PCSYMCRYPT_RSAKEY) -> UINT32, ::libloading::Error>,
    pub SymCryptRsakeySizeofPublicExponent: Result<
        unsafe extern "C" fn(pRsakey: PCSYMCRYPT_RSAKEY, index: UINT32) -> UINT32,
        ::libloading::Error,
    >,
    pub SymCryptRsakeySizeofPrime: Result<
        unsafe extern "C" fn(pkRsakey: PCSYMCRYPT_RSAKEY, index: UINT32) -> UINT32,
        ::libloading::Error,
    >,
    pub SymCryptRsakeyGetNumberOfPublicExponents:
        Result<unsafe extern "C" fn(pkRsakey: PCSYMCRYPT_RSAKEY) -> UINT32, ::libloading::Error>,
    pub SymCryptRsakeyGetNumberOfPrimes:
        Result<unsafe extern "C" fn(pkRsakey: PCSYMCRYPT_RSAKEY) -> UINT32, ::libloading::Error>,
    pub SymCryptRsakeyGenerate: Result<
        unsafe extern "C" fn(
            pkRsakey: PSYMCRYPT_RSAKEY,
            pu64PubExp: PCUINT64,
            nPubExp: UINT32,
            flags: UINT32,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptRsakeySetValue: Result<
        unsafe extern "C" fn(
            pbModulus: PCBYTE,
            cbModulus: SIZE_T,
            pu64PubExp: PCUINT64,
            nPubExp: UINT32,
            ppPrimes: *mut PCBYTE,
            pcbPrimes: *mut SIZE_T,
            nPrimes: UINT32,
            numFormat: SYMCRYPT_NUMBER_FORMAT,
            flags: UINT32,
            pkRsakey: PSYMCRYPT_RSAKEY,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptRsakeyGetValue: Result<
        unsafe extern "C" fn(
            pkRsakey: PCSYMCRYPT_RSAKEY,
            pbModulus: PBYTE,
            cbModulus: SIZE_T,
            pu64PubExp: PUINT64,
            nPubExp: UINT32,
            ppPrimes: *mut PBYTE,
            pcbPrimes: *mut SIZE_T,
            nPrimes: UINT32,
            numFormat: SYMCRYPT_NUMBER_FORMAT,
            flags: UINT32,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptRsakeyGetCrtValue: Result<
        unsafe extern "C" fn(
            pkRsakey: PCSYMCRYPT_RSAKEY,
            ppCrtExponents: *mut PBYTE,
            pcbCrtExponents: *mut SIZE_T,
            nCrtExponents: UINT32,
            pbCrtCoefficient: PBYTE,
            cbCrtCoefficient: SIZE_T,
            pbPrivateExponent: PBYTE,
            cbPrivateExponent: SIZE_T,
            numFormat: SYMCRYPT_NUMBER_FORMAT,
            flags: UINT32,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptRsakeyExtendKeyUsage: Result<
        unsafe extern "C" fn(pkRsakey: PSYMCRYPT_RSAKEY, flags: UINT32) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptEcurveSizeofFieldElement:
        Result<unsafe extern "C" fn(pCurve: PCSYMCRYPT_ECURVE) -> UINT32, ::libloading::Error>,
    pub SymCryptEckeySizeofPublicKey: Result<
        unsafe extern "C" fn(
            pkEckey: PCSYMCRYPT_ECKEY,
            ecPointFormat: SYMCRYPT_ECPOINT_FORMAT,
        ) -> UINT32,
        ::libloading::Error,
    >,
    pub SymCryptEckeySizeofPrivateKey:
        Result<unsafe extern "C" fn(pkEckey: PCSYMCRYPT_ECKEY) -> UINT32, ::libloading::Error>,
    pub SymCryptEckeySetValue: Result<
        unsafe extern "C" fn(
            pbPrivateKey: PCBYTE,
            cbPrivateKey: SIZE_T,
            pbPublicKey: PCBYTE,
            cbPublicKey: SIZE_T,
            numFormat: SYMCRYPT_NUMBER_FORMAT,
            ecPointFormat: SYMCRYPT_ECPOINT_FORMAT,
            flags: UINT32,
            pEckey: PSYMCRYPT_ECKEY,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptEckeySetRandom: Result<
        unsafe extern "C" fn(flags: UINT32, pEckey: PSYMCRYPT_ECKEY) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptEckeyGetValue: Result<
        unsafe extern "C" fn(
            pEckey: PCSYMCRYPT_ECKEY,
            pbPrivateKey: PBYTE,
            cbPrivateKey: SIZE_T,
            pbPublicKey: PBYTE,
            cbPublicKey: SIZE_T,
            numFormat: SYMCRYPT_NUMBER_FORMAT,
            ecPointFormat: SYMCRYPT_ECPOINT_FORMAT,
            flags: UINT32,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptRsaPkcs1Encrypt: Result<
        unsafe extern "C" fn(
            pkRsakey: PCSYMCRYPT_RSAKEY,
            pbSrc: PCBYTE,
            cbSrc: SIZE_T,
            flags: UINT32,
            nfDst: SYMCRYPT_NUMBER_FORMAT,
            pbDst: PBYTE,
            cbDst: SIZE_T,
            pcbDst: *mut SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptRsaPkcs1Decrypt: Result<
        unsafe extern "C" fn(
            pkRsakey: PCSYMCRYPT_RSAKEY,
            pbSrc: PCBYTE,
            cbSrc: SIZE_T,
            nfSrc: SYMCRYPT_NUMBER_FORMAT,
            flags: UINT32,
            pbDst: PBYTE,
            cbDst: SIZE_T,
            pcbDst: *mut SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptRsaOaepEncrypt: Result<
        unsafe extern "C" fn(
            pkRsakey: PCSYMCRYPT_RSAKEY,
            pbSrc: PCBYTE,
            cbSrc: SIZE_T,
            hashAlgorithm: PCSYMCRYPT_HASH,
            pbLabel: PCBYTE,
            cbLabel: SIZE_T,
            flags: UINT32,
            nfDst: SYMCRYPT_NUMBER_FORMAT,
            pbDst: PBYTE,
            cbDst: SIZE_T,
            pcbDst: *mut SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptRsaOaepDecrypt: Result<
        unsafe extern "C" fn(
            pkRsakey: PCSYMCRYPT_RSAKEY,
            pbSrc: PCBYTE,
            cbSrc: SIZE_T,
            nfSrc: SYMCRYPT_NUMBER_FORMAT,
            hashAlgorithm: PCSYMCRYPT_HASH,
            pbLabel: PCBYTE,
            cbLabel: SIZE_T,
            flags: UINT32,
            pbDst: PBYTE,
            cbDst: SIZE_T,
            pcbDst: *mut SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptRsaPkcs1Sign: Result<
        unsafe extern "C" fn(
            pkRsakey: PCSYMCRYPT_RSAKEY,
            pbHashValue: PCBYTE,
            cbHashValue: SIZE_T,
            pHashOIDs: PCSYMCRYPT_OID,
            nOIDCount: SIZE_T,
            flags: UINT32,
            nfSignature: SYMCRYPT_NUMBER_FORMAT,
            pbSignature: PBYTE,
            cbSignature: SIZE_T,
            pcbSignature: *mut SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptRsaPkcs1Verify: Result<
        unsafe extern "C" fn(
            pkRsakey: PCSYMCRYPT_RSAKEY,
            pbHashValue: PCBYTE,
            cbHashValue: SIZE_T,
            pbSignature: PCBYTE,
            cbSignature: SIZE_T,
            nfSignature: SYMCRYPT_NUMBER_FORMAT,
            pHashOID: PCSYMCRYPT_OID,
            nOIDCount: SIZE_T,
            flags: UINT32,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptRsaPssSign: Result<
        unsafe extern "C" fn(
            pkRsakey: PCSYMCRYPT_RSAKEY,
            pbHashValue: PCBYTE,
            cbHashValue: SIZE_T,
            hashAlgorithm: PCSYMCRYPT_HASH,
            cbSalt: SIZE_T,
            flags: UINT32,
            nfSignature: SYMCRYPT_NUMBER_FORMAT,
            pbSignature: PBYTE,
            cbSignature: SIZE_T,
            pcbSignature: *mut SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptRsaPssVerify: Result<
        unsafe extern "C" fn(
            pkRsakey: PCSYMCRYPT_RSAKEY,
            pbHashValue: PCBYTE,
            cbHashValue: SIZE_T,
            pbSignature: PCBYTE,
            cbSignature: SIZE_T,
            nfSignature: SYMCRYPT_NUMBER_FORMAT,
            hashAlgorithm: PCSYMCRYPT_HASH,
            cbSalt: SIZE_T,
            flags: UINT32,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptEcDsaSign: Result<
        unsafe extern "C" fn(
            pKey: PCSYMCRYPT_ECKEY,
            pbHashValue: PCBYTE,
            cbHashValue: SIZE_T,
            format: SYMCRYPT_NUMBER_FORMAT,
            flags: UINT32,
            pbSignature: PBYTE,
            cbSignature: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptEcDsaVerify: Result<
        unsafe extern "C" fn(
            pKey: PCSYMCRYPT_ECKEY,
            pbHashValue: PCBYTE,
            cbHashValue: SIZE_T,
            pbSignature: PCBYTE,
            cbSignature: SIZE_T,
            format: SYMCRYPT_NUMBER_FORMAT,
            flags: UINT32,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
    pub SymCryptEcDhSecretAgreement: Result<
        unsafe extern "C" fn(
            pkPrivate: PCSYMCRYPT_ECKEY,
            pkPublic: PCSYMCRYPT_ECKEY,
            format: SYMCRYPT_NUMBER_FORMAT,
            flags: UINT32,
            pbAgreedSecret: PBYTE,
            cbAgreedSecret: SIZE_T,
        ) -> SYMCRYPT_ERROR,
        ::libloading::Error,
    >,
}
impl symcrypt {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let SymCryptWipe = __library.get(b"SymCryptWipe\0").map(|sym| *sym);
        let SymCryptLoadMsbFirstUint64 = __library
            .get(b"SymCryptLoadMsbFirstUint64\0")
            .map(|sym| *sym);
        let SymCryptStoreMsbFirstUint64 = __library
            .get(b"SymCryptStoreMsbFirstUint64\0")
            .map(|sym| *sym);
        let SymCryptModuleInit = __library.get(b"SymCryptModuleInit\0").map(|sym| *sym);
        let SymCryptMd5 = __library.get(b"SymCryptMd5\0").map(|sym| *sym);
        let SymCryptMd5Init = __library.get(b"SymCryptMd5Init\0").map(|sym| *sym);
        let SymCryptMd5Append = __library.get(b"SymCryptMd5Append\0").map(|sym| *sym);
        let SymCryptMd5Result = __library.get(b"SymCryptMd5Result\0").map(|sym| *sym);
        let SymCryptMd5StateCopy = __library.get(b"SymCryptMd5StateCopy\0").map(|sym| *sym);
        let SymCryptSha1 = __library.get(b"SymCryptSha1\0").map(|sym| *sym);
        let SymCryptSha1Init = __library.get(b"SymCryptSha1Init\0").map(|sym| *sym);
        let SymCryptSha1Append = __library.get(b"SymCryptSha1Append\0").map(|sym| *sym);
        let SymCryptSha1Result = __library.get(b"SymCryptSha1Result\0").map(|sym| *sym);
        let SymCryptSha1StateCopy = __library.get(b"SymCryptSha1StateCopy\0").map(|sym| *sym);
        let SymCryptSha256 = __library.get(b"SymCryptSha256\0").map(|sym| *sym);
        let SymCryptSha256Init = __library.get(b"SymCryptSha256Init\0").map(|sym| *sym);
        let SymCryptSha256Append = __library.get(b"SymCryptSha256Append\0").map(|sym| *sym);
        let SymCryptSha256Result = __library.get(b"SymCryptSha256Result\0").map(|sym| *sym);
        let SymCryptSha256StateCopy = __library.get(b"SymCryptSha256StateCopy\0").map(|sym| *sym);
        let SymCryptSha384 = __library.get(b"SymCryptSha384\0").map(|sym| *sym);
        let SymCryptSha384Init = __library.get(b"SymCryptSha384Init\0").map(|sym| *sym);
        let SymCryptSha384Append = __library.get(b"SymCryptSha384Append\0").map(|sym| *sym);
        let SymCryptSha384Result = __library.get(b"SymCryptSha384Result\0").map(|sym| *sym);
        let SymCryptSha384StateCopy = __library.get(b"SymCryptSha384StateCopy\0").map(|sym| *sym);
        let SymCryptSha512 = __library.get(b"SymCryptSha512\0").map(|sym| *sym);
        let SymCryptSha512Init = __library.get(b"SymCryptSha512Init\0").map(|sym| *sym);
        let SymCryptSha512Append = __library.get(b"SymCryptSha512Append\0").map(|sym| *sym);
        let SymCryptSha512Result = __library.get(b"SymCryptSha512Result\0").map(|sym| *sym);
        let SymCryptSha512StateCopy = __library.get(b"SymCryptSha512StateCopy\0").map(|sym| *sym);
        let SymCryptSha3_256 = __library.get(b"SymCryptSha3_256\0").map(|sym| *sym);
        let SymCryptSha3_256Init = __library.get(b"SymCryptSha3_256Init\0").map(|sym| *sym);
        let SymCryptSha3_256Append = __library.get(b"SymCryptSha3_256Append\0").map(|sym| *sym);
        let SymCryptSha3_256Result = __library.get(b"SymCryptSha3_256Result\0").map(|sym| *sym);
        let SymCryptSha3_256StateCopy = __library
            .get(b"SymCryptSha3_256StateCopy\0")
            .map(|sym| *sym);
        let SymCryptSha3_384 = __library.get(b"SymCryptSha3_384\0").map(|sym| *sym);
        let SymCryptSha3_384Init = __library.get(b"SymCryptSha3_384Init\0").map(|sym| *sym);
        let SymCryptSha3_384Append = __library.get(b"SymCryptSha3_384Append\0").map(|sym| *sym);
        let SymCryptSha3_384Result = __library.get(b"SymCryptSha3_384Result\0").map(|sym| *sym);
        let SymCryptSha3_384StateCopy = __library
            .get(b"SymCryptSha3_384StateCopy\0")
            .map(|sym| *sym);
        let SymCryptSha3_512 = __library.get(b"SymCryptSha3_512\0").map(|sym| *sym);
        let SymCryptSha3_512Init = __library.get(b"SymCryptSha3_512Init\0").map(|sym| *sym);
        let SymCryptSha3_512Append = __library.get(b"SymCryptSha3_512Append\0").map(|sym| *sym);
        let SymCryptSha3_512Result = __library.get(b"SymCryptSha3_512Result\0").map(|sym| *sym);
        let SymCryptSha3_512StateCopy = __library
            .get(b"SymCryptSha3_512StateCopy\0")
            .map(|sym| *sym);
        let SymCryptHmacMd5ExpandKey = __library.get(b"SymCryptHmacMd5ExpandKey\0").map(|sym| *sym);
        let SymCryptHmacMd5 = __library.get(b"SymCryptHmacMd5\0").map(|sym| *sym);
        let SymCryptHmacMd5StateCopy = __library.get(b"SymCryptHmacMd5StateCopy\0").map(|sym| *sym);
        let SymCryptHmacMd5Init = __library.get(b"SymCryptHmacMd5Init\0").map(|sym| *sym);
        let SymCryptHmacMd5Append = __library.get(b"SymCryptHmacMd5Append\0").map(|sym| *sym);
        let SymCryptHmacMd5Result = __library.get(b"SymCryptHmacMd5Result\0").map(|sym| *sym);
        let SymCryptHmacSha1ExpandKey = __library
            .get(b"SymCryptHmacSha1ExpandKey\0")
            .map(|sym| *sym);
        let SymCryptHmacSha1 = __library.get(b"SymCryptHmacSha1\0").map(|sym| *sym);
        let SymCryptHmacSha1StateCopy = __library
            .get(b"SymCryptHmacSha1StateCopy\0")
            .map(|sym| *sym);
        let SymCryptHmacSha1Init = __library.get(b"SymCryptHmacSha1Init\0").map(|sym| *sym);
        let SymCryptHmacSha1Append = __library.get(b"SymCryptHmacSha1Append\0").map(|sym| *sym);
        let SymCryptHmacSha1Result = __library.get(b"SymCryptHmacSha1Result\0").map(|sym| *sym);
        let SymCryptHmacSha256ExpandKey = __library
            .get(b"SymCryptHmacSha256ExpandKey\0")
            .map(|sym| *sym);
        let SymCryptHmacSha256 = __library.get(b"SymCryptHmacSha256\0").map(|sym| *sym);
        let SymCryptHmacSha256StateCopy = __library
            .get(b"SymCryptHmacSha256StateCopy\0")
            .map(|sym| *sym);
        let SymCryptHmacSha256Init = __library.get(b"SymCryptHmacSha256Init\0").map(|sym| *sym);
        let SymCryptHmacSha256Append = __library.get(b"SymCryptHmacSha256Append\0").map(|sym| *sym);
        let SymCryptHmacSha256Result = __library.get(b"SymCryptHmacSha256Result\0").map(|sym| *sym);
        let SymCryptHmacSha384ExpandKey = __library
            .get(b"SymCryptHmacSha384ExpandKey\0")
            .map(|sym| *sym);
        let SymCryptHmacSha384 = __library.get(b"SymCryptHmacSha384\0").map(|sym| *sym);
        let SymCryptHmacSha384StateCopy = __library
            .get(b"SymCryptHmacSha384StateCopy\0")
            .map(|sym| *sym);
        let SymCryptHmacSha384Init = __library.get(b"SymCryptHmacSha384Init\0").map(|sym| *sym);
        let SymCryptHmacSha384Append = __library.get(b"SymCryptHmacSha384Append\0").map(|sym| *sym);
        let SymCryptHmacSha384Result = __library.get(b"SymCryptHmacSha384Result\0").map(|sym| *sym);
        let SymCryptHmacSha512ExpandKey = __library
            .get(b"SymCryptHmacSha512ExpandKey\0")
            .map(|sym| *sym);
        let SymCryptHmacSha512 = __library.get(b"SymCryptHmacSha512\0").map(|sym| *sym);
        let SymCryptHmacSha512StateCopy = __library
            .get(b"SymCryptHmacSha512StateCopy\0")
            .map(|sym| *sym);
        let SymCryptHmacSha512Init = __library.get(b"SymCryptHmacSha512Init\0").map(|sym| *sym);
        let SymCryptHmacSha512Append = __library.get(b"SymCryptHmacSha512Append\0").map(|sym| *sym);
        let SymCryptHmacSha512Result = __library.get(b"SymCryptHmacSha512Result\0").map(|sym| *sym);
        let SymCryptChaCha20Poly1305Encrypt = __library
            .get(b"SymCryptChaCha20Poly1305Encrypt\0")
            .map(|sym| *sym);
        let SymCryptChaCha20Poly1305Decrypt = __library
            .get(b"SymCryptChaCha20Poly1305Decrypt\0")
            .map(|sym| *sym);
        let SymCryptGcmValidateParameters = __library
            .get(b"SymCryptGcmValidateParameters\0")
            .map(|sym| *sym);
        let SymCryptGcmExpandKey = __library.get(b"SymCryptGcmExpandKey\0").map(|sym| *sym);
        let SymCryptGcmEncrypt = __library.get(b"SymCryptGcmEncrypt\0").map(|sym| *sym);
        let SymCryptGcmDecrypt = __library.get(b"SymCryptGcmDecrypt\0").map(|sym| *sym);
        let SymCryptGcmInit = __library.get(b"SymCryptGcmInit\0").map(|sym| *sym);
        let SymCryptGcmStateCopy = __library.get(b"SymCryptGcmStateCopy\0").map(|sym| *sym);
        let SymCryptGcmAuthPart = __library.get(b"SymCryptGcmAuthPart\0").map(|sym| *sym);
        let SymCryptGcmEncryptPart = __library.get(b"SymCryptGcmEncryptPart\0").map(|sym| *sym);
        let SymCryptGcmEncryptFinal = __library.get(b"SymCryptGcmEncryptFinal\0").map(|sym| *sym);
        let SymCryptGcmDecryptPart = __library.get(b"SymCryptGcmDecryptPart\0").map(|sym| *sym);
        let SymCryptGcmDecryptFinal = __library.get(b"SymCryptGcmDecryptFinal\0").map(|sym| *sym);
        let SymCryptTlsPrf1_2ExpandKey = __library
            .get(b"SymCryptTlsPrf1_2ExpandKey\0")
            .map(|sym| *sym);
        let SymCryptTlsPrf1_2Derive = __library.get(b"SymCryptTlsPrf1_2Derive\0").map(|sym| *sym);
        let SymCryptTlsPrf1_2 = __library.get(b"SymCryptTlsPrf1_2\0").map(|sym| *sym);
        let SymCryptHkdfExpandKey = __library.get(b"SymCryptHkdfExpandKey\0").map(|sym| *sym);
        let SymCryptHkdfExtractPrk = __library.get(b"SymCryptHkdfExtractPrk\0").map(|sym| *sym);
        let SymCryptHkdfPrkExpandKey = __library.get(b"SymCryptHkdfPrkExpandKey\0").map(|sym| *sym);
        let SymCryptHkdfDerive = __library.get(b"SymCryptHkdfDerive\0").map(|sym| *sym);
        let SymCryptHkdf = __library.get(b"SymCryptHkdf\0").map(|sym| *sym);
        let SymCryptHkdfSelfTest = __library.get(b"SymCryptHkdfSelfTest\0").map(|sym| *sym);
        let SymCryptRandom = __library.get(b"SymCryptRandom\0").map(|sym| *sym);
        let SymCryptRsakeyAllocate = __library.get(b"SymCryptRsakeyAllocate\0").map(|sym| *sym);
        let SymCryptRsakeyFree = __library.get(b"SymCryptRsakeyFree\0").map(|sym| *sym);
        let SymCryptEcurveAllocate = __library.get(b"SymCryptEcurveAllocate\0").map(|sym| *sym);
        let SymCryptEcurveFree = __library.get(b"SymCryptEcurveFree\0").map(|sym| *sym);
        let SymCryptEckeyAllocate = __library.get(b"SymCryptEckeyAllocate\0").map(|sym| *sym);
        let SymCryptEckeyFree = __library.get(b"SymCryptEckeyFree\0").map(|sym| *sym);
        let SymCryptRsakeyHasPrivateKey = __library
            .get(b"SymCryptRsakeyHasPrivateKey\0")
            .map(|sym| *sym);
        let SymCryptRsakeySizeofModulus = __library
            .get(b"SymCryptRsakeySizeofModulus\0")
            .map(|sym| *sym);
        let SymCryptRsakeyModulusBits = __library
            .get(b"SymCryptRsakeyModulusBits\0")
            .map(|sym| *sym);
        let SymCryptRsakeySizeofPublicExponent = __library
            .get(b"SymCryptRsakeySizeofPublicExponent\0")
            .map(|sym| *sym);
        let SymCryptRsakeySizeofPrime = __library
            .get(b"SymCryptRsakeySizeofPrime\0")
            .map(|sym| *sym);
        let SymCryptRsakeyGetNumberOfPublicExponents = __library
            .get(b"SymCryptRsakeyGetNumberOfPublicExponents\0")
            .map(|sym| *sym);
        let SymCryptRsakeyGetNumberOfPrimes = __library
            .get(b"SymCryptRsakeyGetNumberOfPrimes\0")
            .map(|sym| *sym);
        let SymCryptRsakeyGenerate = __library.get(b"SymCryptRsakeyGenerate\0").map(|sym| *sym);
        let SymCryptRsakeySetValue = __library.get(b"SymCryptRsakeySetValue\0").map(|sym| *sym);
        let SymCryptRsakeyGetValue = __library.get(b"SymCryptRsakeyGetValue\0").map(|sym| *sym);
        let SymCryptRsakeyGetCrtValue = __library
            .get(b"SymCryptRsakeyGetCrtValue\0")
            .map(|sym| *sym);
        let SymCryptRsakeyExtendKeyUsage = __library
            .get(b"SymCryptRsakeyExtendKeyUsage\0")
            .map(|sym| *sym);
        let SymCryptEcurveSizeofFieldElement = __library
            .get(b"SymCryptEcurveSizeofFieldElement\0")
            .map(|sym| *sym);
        let SymCryptEckeySizeofPublicKey = __library
            .get(b"SymCryptEckeySizeofPublicKey\0")
            .map(|sym| *sym);
        let SymCryptEckeySizeofPrivateKey = __library
            .get(b"SymCryptEckeySizeofPrivateKey\0")
            .map(|sym| *sym);
        let SymCryptEckeySetValue = __library.get(b"SymCryptEckeySetValue\0").map(|sym| *sym);
        let SymCryptEckeySetRandom = __library.get(b"SymCryptEckeySetRandom\0").map(|sym| *sym);
        let SymCryptEckeyGetValue = __library.get(b"SymCryptEckeyGetValue\0").map(|sym| *sym);
        let SymCryptRsaPkcs1Encrypt = __library.get(b"SymCryptRsaPkcs1Encrypt\0").map(|sym| *sym);
        let SymCryptRsaPkcs1Decrypt = __library.get(b"SymCryptRsaPkcs1Decrypt\0").map(|sym| *sym);
        let SymCryptRsaOaepEncrypt = __library.get(b"SymCryptRsaOaepEncrypt\0").map(|sym| *sym);
        let SymCryptRsaOaepDecrypt = __library.get(b"SymCryptRsaOaepDecrypt\0").map(|sym| *sym);
        let SymCryptRsaPkcs1Sign = __library.get(b"SymCryptRsaPkcs1Sign\0").map(|sym| *sym);
        let SymCryptRsaPkcs1Verify = __library.get(b"SymCryptRsaPkcs1Verify\0").map(|sym| *sym);
        let SymCryptRsaPssSign = __library.get(b"SymCryptRsaPssSign\0").map(|sym| *sym);
        let SymCryptRsaPssVerify = __library.get(b"SymCryptRsaPssVerify\0").map(|sym| *sym);
        let SymCryptEcDsaSign = __library.get(b"SymCryptEcDsaSign\0").map(|sym| *sym);
        let SymCryptEcDsaVerify = __library.get(b"SymCryptEcDsaVerify\0").map(|sym| *sym);
        let SymCryptEcDhSecretAgreement = __library
            .get(b"SymCryptEcDhSecretAgreement\0")
            .map(|sym| *sym);
        Ok(symcrypt {
            __library,
            SymCryptWipe,
            SymCryptLoadMsbFirstUint64,
            SymCryptStoreMsbFirstUint64,
            SymCryptModuleInit,
            SymCryptMd5,
            SymCryptMd5Init,
            SymCryptMd5Append,
            SymCryptMd5Result,
            SymCryptMd5StateCopy,
            SymCryptSha1,
            SymCryptSha1Init,
            SymCryptSha1Append,
            SymCryptSha1Result,
            SymCryptSha1StateCopy,
            SymCryptSha256,
            SymCryptSha256Init,
            SymCryptSha256Append,
            SymCryptSha256Result,
            SymCryptSha256StateCopy,
            SymCryptSha384,
            SymCryptSha384Init,
            SymCryptSha384Append,
            SymCryptSha384Result,
            SymCryptSha384StateCopy,
            SymCryptSha512,
            SymCryptSha512Init,
            SymCryptSha512Append,
            SymCryptSha512Result,
            SymCryptSha512StateCopy,
            SymCryptSha3_256,
            SymCryptSha3_256Init,
            SymCryptSha3_256Append,
            SymCryptSha3_256Result,
            SymCryptSha3_256StateCopy,
            SymCryptSha3_384,
            SymCryptSha3_384Init,
            SymCryptSha3_384Append,
            SymCryptSha3_384Result,
            SymCryptSha3_384StateCopy,
            SymCryptSha3_512,
            SymCryptSha3_512Init,
            SymCryptSha3_512Append,
            SymCryptSha3_512Result,
            SymCryptSha3_512StateCopy,
            SymCryptHmacMd5ExpandKey,
            SymCryptHmacMd5,
            SymCryptHmacMd5StateCopy,
            SymCryptHmacMd5Init,
            SymCryptHmacMd5Append,
            SymCryptHmacMd5Result,
            SymCryptHmacSha1ExpandKey,
            SymCryptHmacSha1,
            SymCryptHmacSha1StateCopy,
            SymCryptHmacSha1Init,
            SymCryptHmacSha1Append,
            SymCryptHmacSha1Result,
            SymCryptHmacSha256ExpandKey,
            SymCryptHmacSha256,
            SymCryptHmacSha256StateCopy,
            SymCryptHmacSha256Init,
            SymCryptHmacSha256Append,
            SymCryptHmacSha256Result,
            SymCryptHmacSha384ExpandKey,
            SymCryptHmacSha384,
            SymCryptHmacSha384StateCopy,
            SymCryptHmacSha384Init,
            SymCryptHmacSha384Append,
            SymCryptHmacSha384Result,
            SymCryptHmacSha512ExpandKey,
            SymCryptHmacSha512,
            SymCryptHmacSha512StateCopy,
            SymCryptHmacSha512Init,
            SymCryptHmacSha512Append,
            SymCryptHmacSha512Result,
            SymCryptChaCha20Poly1305Encrypt,
            SymCryptChaCha20Poly1305Decrypt,
            SymCryptGcmValidateParameters,
            SymCryptGcmExpandKey,
            SymCryptGcmEncrypt,
            SymCryptGcmDecrypt,
            SymCryptGcmInit,
            SymCryptGcmStateCopy,
            SymCryptGcmAuthPart,
            SymCryptGcmEncryptPart,
            SymCryptGcmEncryptFinal,
            SymCryptGcmDecryptPart,
            SymCryptGcmDecryptFinal,
            SymCryptTlsPrf1_2ExpandKey,
            SymCryptTlsPrf1_2Derive,
            SymCryptTlsPrf1_2,
            SymCryptHkdfExpandKey,
            SymCryptHkdfExtractPrk,
            SymCryptHkdfPrkExpandKey,
            SymCryptHkdfDerive,
            SymCryptHkdf,
            SymCryptHkdfSelfTest,
            SymCryptRandom,
            SymCryptRsakeyAllocate,
            SymCryptRsakeyFree,
            SymCryptEcurveAllocate,
            SymCryptEcurveFree,
            SymCryptEckeyAllocate,
            SymCryptEckeyFree,
            SymCryptRsakeyHasPrivateKey,
            SymCryptRsakeySizeofModulus,
            SymCryptRsakeyModulusBits,
            SymCryptRsakeySizeofPublicExponent,
            SymCryptRsakeySizeofPrime,
            SymCryptRsakeyGetNumberOfPublicExponents,
            SymCryptRsakeyGetNumberOfPrimes,
            SymCryptRsakeyGenerate,
            SymCryptRsakeySetValue,
            SymCryptRsakeyGetValue,
            SymCryptRsakeyGetCrtValue,
            SymCryptRsakeyExtendKeyUsage,
            SymCryptEcurveSizeofFieldElement,
            SymCryptEckeySizeofPublicKey,
            SymCryptEckeySizeofPrivateKey,
            SymCryptEckeySetValue,
            SymCryptEckeySetRandom,
            SymCryptEckeyGetValue,
            SymCryptRsaPkcs1Encrypt,
            SymCryptRsaPkcs1Decrypt,
            SymCryptRsaOaepEncrypt,
            SymCryptRsaOaepDecrypt,
            SymCryptRsaPkcs1Sign,
            SymCryptRsaPkcs1Verify,
            SymCryptRsaPssSign,
            SymCryptRsaPssVerify,
            SymCryptEcDsaSign,
            SymCryptEcDsaVerify,
            SymCryptEcDhSecretAgreement,
        })
    }
    pub unsafe fn SymCryptWipe(&self, pbData: PVOID, cbData: SIZE_T) {
        (self
            .SymCryptWipe
            .as_ref()
            .expect("Expected function, got error."))(pbData, cbData)
    }
    pub unsafe fn SymCryptLoadMsbFirstUint64(
        &self,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        pDst: PUINT64,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptLoadMsbFirstUint64
            .as_ref()
            .expect("Expected function, got error."))(pbSrc, cbSrc, pDst)
    }
    pub unsafe fn SymCryptStoreMsbFirstUint64(
        &self,
        src: UINT64,
        pbDst: PBYTE,
        cbDst: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptStoreMsbFirstUint64
            .as_ref()
            .expect("Expected function, got error."))(src, pbDst, cbDst)
    }
    pub unsafe fn SymCryptModuleInit(&self, api: UINT32, minor: UINT32) {
        (self
            .SymCryptModuleInit
            .as_ref()
            .expect("Expected function, got error."))(api, minor)
    }
    pub unsafe fn SymCryptMd5(&self, pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE) {
        (self
            .SymCryptMd5
            .as_ref()
            .expect("Expected function, got error."))(pbData, cbData, pbResult)
    }
    pub unsafe fn SymCryptMd5Init(&self, pState: PSYMCRYPT_MD5_STATE) {
        (self
            .SymCryptMd5Init
            .as_ref()
            .expect("Expected function, got error."))(pState)
    }
    pub unsafe fn SymCryptMd5Append(
        &self,
        pState: PSYMCRYPT_MD5_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    ) {
        (self
            .SymCryptMd5Append
            .as_ref()
            .expect("Expected function, got error."))(pState, pbData, cbData)
    }
    pub unsafe fn SymCryptMd5Result(&self, pState: PSYMCRYPT_MD5_STATE, pbResult: PBYTE) {
        (self
            .SymCryptMd5Result
            .as_ref()
            .expect("Expected function, got error."))(pState, pbResult)
    }
    pub unsafe fn SymCryptMd5StateCopy(
        &self,
        pSrc: PCSYMCRYPT_MD5_STATE,
        pDst: PSYMCRYPT_MD5_STATE,
    ) {
        (self
            .SymCryptMd5StateCopy
            .as_ref()
            .expect("Expected function, got error."))(pSrc, pDst)
    }
    pub unsafe fn SymCryptSha1(&self, pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE) {
        (self
            .SymCryptSha1
            .as_ref()
            .expect("Expected function, got error."))(pbData, cbData, pbResult)
    }
    pub unsafe fn SymCryptSha1Init(&self, pState: PSYMCRYPT_SHA1_STATE) {
        (self
            .SymCryptSha1Init
            .as_ref()
            .expect("Expected function, got error."))(pState)
    }
    pub unsafe fn SymCryptSha1Append(
        &self,
        pState: PSYMCRYPT_SHA1_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    ) {
        (self
            .SymCryptSha1Append
            .as_ref()
            .expect("Expected function, got error."))(pState, pbData, cbData)
    }
    pub unsafe fn SymCryptSha1Result(&self, pState: PSYMCRYPT_SHA1_STATE, pbResult: PBYTE) {
        (self
            .SymCryptSha1Result
            .as_ref()
            .expect("Expected function, got error."))(pState, pbResult)
    }
    pub unsafe fn SymCryptSha1StateCopy(
        &self,
        pSrc: PCSYMCRYPT_SHA1_STATE,
        pDst: PSYMCRYPT_SHA1_STATE,
    ) {
        (self
            .SymCryptSha1StateCopy
            .as_ref()
            .expect("Expected function, got error."))(pSrc, pDst)
    }
    pub unsafe fn SymCryptSha256(&self, pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE) {
        (self
            .SymCryptSha256
            .as_ref()
            .expect("Expected function, got error."))(pbData, cbData, pbResult)
    }
    pub unsafe fn SymCryptSha256Init(&self, pState: PSYMCRYPT_SHA256_STATE) {
        (self
            .SymCryptSha256Init
            .as_ref()
            .expect("Expected function, got error."))(pState)
    }
    pub unsafe fn SymCryptSha256Append(
        &self,
        pState: PSYMCRYPT_SHA256_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    ) {
        (self
            .SymCryptSha256Append
            .as_ref()
            .expect("Expected function, got error."))(pState, pbData, cbData)
    }
    pub unsafe fn SymCryptSha256Result(&self, pState: PSYMCRYPT_SHA256_STATE, pbResult: PBYTE) {
        (self
            .SymCryptSha256Result
            .as_ref()
            .expect("Expected function, got error."))(pState, pbResult)
    }
    pub unsafe fn SymCryptSha256StateCopy(
        &self,
        pSrc: PCSYMCRYPT_SHA256_STATE,
        pDst: PSYMCRYPT_SHA256_STATE,
    ) {
        (self
            .SymCryptSha256StateCopy
            .as_ref()
            .expect("Expected function, got error."))(pSrc, pDst)
    }
    pub unsafe fn SymCryptSha384(&self, pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE) {
        (self
            .SymCryptSha384
            .as_ref()
            .expect("Expected function, got error."))(pbData, cbData, pbResult)
    }
    pub unsafe fn SymCryptSha384Init(&self, pState: PSYMCRYPT_SHA384_STATE) {
        (self
            .SymCryptSha384Init
            .as_ref()
            .expect("Expected function, got error."))(pState)
    }
    pub unsafe fn SymCryptSha384Append(
        &self,
        pState: PSYMCRYPT_SHA384_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    ) {
        (self
            .SymCryptSha384Append
            .as_ref()
            .expect("Expected function, got error."))(pState, pbData, cbData)
    }
    pub unsafe fn SymCryptSha384Result(&self, pState: PSYMCRYPT_SHA384_STATE, pbResult: PBYTE) {
        (self
            .SymCryptSha384Result
            .as_ref()
            .expect("Expected function, got error."))(pState, pbResult)
    }
    pub unsafe fn SymCryptSha384StateCopy(
        &self,
        pSrc: PCSYMCRYPT_SHA384_STATE,
        pDst: PSYMCRYPT_SHA384_STATE,
    ) {
        (self
            .SymCryptSha384StateCopy
            .as_ref()
            .expect("Expected function, got error."))(pSrc, pDst)
    }
    pub unsafe fn SymCryptSha512(&self, pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE) {
        (self
            .SymCryptSha512
            .as_ref()
            .expect("Expected function, got error."))(pbData, cbData, pbResult)
    }
    pub unsafe fn SymCryptSha512Init(&self, pState: PSYMCRYPT_SHA512_STATE) {
        (self
            .SymCryptSha512Init
            .as_ref()
            .expect("Expected function, got error."))(pState)
    }
    pub unsafe fn SymCryptSha512Append(
        &self,
        pState: PSYMCRYPT_SHA512_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    ) {
        (self
            .SymCryptSha512Append
            .as_ref()
            .expect("Expected function, got error."))(pState, pbData, cbData)
    }
    pub unsafe fn SymCryptSha512Result(&self, pState: PSYMCRYPT_SHA512_STATE, pbResult: PBYTE) {
        (self
            .SymCryptSha512Result
            .as_ref()
            .expect("Expected function, got error."))(pState, pbResult)
    }
    pub unsafe fn SymCryptSha512StateCopy(
        &self,
        pSrc: PCSYMCRYPT_SHA512_STATE,
        pDst: PSYMCRYPT_SHA512_STATE,
    ) {
        (self
            .SymCryptSha512StateCopy
            .as_ref()
            .expect("Expected function, got error."))(pSrc, pDst)
    }
    pub unsafe fn SymCryptSha3_256(&self, pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE) {
        (self
            .SymCryptSha3_256
            .as_ref()
            .expect("Expected function, got error."))(pbData, cbData, pbResult)
    }
    pub unsafe fn SymCryptSha3_256Init(&self, pState: PSYMCRYPT_SHA3_256_STATE) {
        (self
            .SymCryptSha3_256Init
            .as_ref()
            .expect("Expected function, got error."))(pState)
    }
    pub unsafe fn SymCryptSha3_256Append(
        &self,
        pState: PSYMCRYPT_SHA3_256_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    ) {
        (self
            .SymCryptSha3_256Append
            .as_ref()
            .expect("Expected function, got error."))(pState, pbData, cbData)
    }
    pub unsafe fn SymCryptSha3_256Result(&self, pState: PSYMCRYPT_SHA3_256_STATE, pbResult: PBYTE) {
        (self
            .SymCryptSha3_256Result
            .as_ref()
            .expect("Expected function, got error."))(pState, pbResult)
    }
    pub unsafe fn SymCryptSha3_256StateCopy(
        &self,
        pSrc: PCSYMCRYPT_SHA3_256_STATE,
        pDst: PSYMCRYPT_SHA3_256_STATE,
    ) {
        (self
            .SymCryptSha3_256StateCopy
            .as_ref()
            .expect("Expected function, got error."))(pSrc, pDst)
    }
    pub unsafe fn SymCryptSha3_384(&self, pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE) {
        (self
            .SymCryptSha3_384
            .as_ref()
            .expect("Expected function, got error."))(pbData, cbData, pbResult)
    }
    pub unsafe fn SymCryptSha3_384Init(&self, pState: PSYMCRYPT_SHA3_384_STATE) {
        (self
            .SymCryptSha3_384Init
            .as_ref()
            .expect("Expected function, got error."))(pState)
    }
    pub unsafe fn SymCryptSha3_384Append(
        &self,
        pState: PSYMCRYPT_SHA3_384_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    ) {
        (self
            .SymCryptSha3_384Append
            .as_ref()
            .expect("Expected function, got error."))(pState, pbData, cbData)
    }
    pub unsafe fn SymCryptSha3_384Result(&self, pState: PSYMCRYPT_SHA3_384_STATE, pbResult: PBYTE) {
        (self
            .SymCryptSha3_384Result
            .as_ref()
            .expect("Expected function, got error."))(pState, pbResult)
    }
    pub unsafe fn SymCryptSha3_384StateCopy(
        &self,
        pSrc: PCSYMCRYPT_SHA3_384_STATE,
        pDst: PSYMCRYPT_SHA3_384_STATE,
    ) {
        (self
            .SymCryptSha3_384StateCopy
            .as_ref()
            .expect("Expected function, got error."))(pSrc, pDst)
    }
    pub unsafe fn SymCryptSha3_512(&self, pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE) {
        (self
            .SymCryptSha3_512
            .as_ref()
            .expect("Expected function, got error."))(pbData, cbData, pbResult)
    }
    pub unsafe fn SymCryptSha3_512Init(&self, pState: PSYMCRYPT_SHA3_512_STATE) {
        (self
            .SymCryptSha3_512Init
            .as_ref()
            .expect("Expected function, got error."))(pState)
    }
    pub unsafe fn SymCryptSha3_512Append(
        &self,
        pState: PSYMCRYPT_SHA3_512_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    ) {
        (self
            .SymCryptSha3_512Append
            .as_ref()
            .expect("Expected function, got error."))(pState, pbData, cbData)
    }
    pub unsafe fn SymCryptSha3_512Result(&self, pState: PSYMCRYPT_SHA3_512_STATE, pbResult: PBYTE) {
        (self
            .SymCryptSha3_512Result
            .as_ref()
            .expect("Expected function, got error."))(pState, pbResult)
    }
    pub unsafe fn SymCryptSha3_512StateCopy(
        &self,
        pSrc: PCSYMCRYPT_SHA3_512_STATE,
        pDst: PSYMCRYPT_SHA3_512_STATE,
    ) {
        (self
            .SymCryptSha3_512StateCopy
            .as_ref()
            .expect("Expected function, got error."))(pSrc, pDst)
    }
    pub unsafe fn SymCryptHmacMd5ExpandKey(
        &self,
        pExpandedKey: PSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptHmacMd5ExpandKey
            .as_ref()
            .expect("Expected function, got error."))(pExpandedKey, pbKey, cbKey)
    }
    pub unsafe fn SymCryptHmacMd5(
        &self,
        pExpandedKey: PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    ) {
        (self
            .SymCryptHmacMd5
            .as_ref()
            .expect("Expected function, got error."))(pExpandedKey, pbData, cbData, pbResult)
    }
    pub unsafe fn SymCryptHmacMd5StateCopy(
        &self,
        pSrc: PCSYMCRYPT_HMAC_MD5_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_MD5_STATE,
    ) {
        (self
            .SymCryptHmacMd5StateCopy
            .as_ref()
            .expect("Expected function, got error."))(pSrc, pExpandedKey, pDst)
    }
    pub unsafe fn SymCryptHmacMd5Init(
        &self,
        pState: PSYMCRYPT_HMAC_MD5_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
    ) {
        (self
            .SymCryptHmacMd5Init
            .as_ref()
            .expect("Expected function, got error."))(pState, pExpandedKey)
    }
    pub unsafe fn SymCryptHmacMd5Append(
        &self,
        pState: PSYMCRYPT_HMAC_MD5_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    ) {
        (self
            .SymCryptHmacMd5Append
            .as_ref()
            .expect("Expected function, got error."))(pState, pbData, cbData)
    }
    pub unsafe fn SymCryptHmacMd5Result(&self, pState: PSYMCRYPT_HMAC_MD5_STATE, pbResult: PBYTE) {
        (self
            .SymCryptHmacMd5Result
            .as_ref()
            .expect("Expected function, got error."))(pState, pbResult)
    }
    pub unsafe fn SymCryptHmacSha1ExpandKey(
        &self,
        pExpandedKey: PSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptHmacSha1ExpandKey
            .as_ref()
            .expect("Expected function, got error."))(pExpandedKey, pbKey, cbKey)
    }
    pub unsafe fn SymCryptHmacSha1(
        &self,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    ) {
        (self
            .SymCryptHmacSha1
            .as_ref()
            .expect("Expected function, got error."))(pExpandedKey, pbData, cbData, pbResult)
    }
    pub unsafe fn SymCryptHmacSha1StateCopy(
        &self,
        pSrc: PCSYMCRYPT_HMAC_SHA1_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA1_STATE,
    ) {
        (self
            .SymCryptHmacSha1StateCopy
            .as_ref()
            .expect("Expected function, got error."))(pSrc, pExpandedKey, pDst)
    }
    pub unsafe fn SymCryptHmacSha1Init(
        &self,
        pState: PSYMCRYPT_HMAC_SHA1_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
    ) {
        (self
            .SymCryptHmacSha1Init
            .as_ref()
            .expect("Expected function, got error."))(pState, pExpandedKey)
    }
    pub unsafe fn SymCryptHmacSha1Append(
        &self,
        pState: PSYMCRYPT_HMAC_SHA1_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    ) {
        (self
            .SymCryptHmacSha1Append
            .as_ref()
            .expect("Expected function, got error."))(pState, pbData, cbData)
    }
    pub unsafe fn SymCryptHmacSha1Result(
        &self,
        pState: PSYMCRYPT_HMAC_SHA1_STATE,
        pbResult: PBYTE,
    ) {
        (self
            .SymCryptHmacSha1Result
            .as_ref()
            .expect("Expected function, got error."))(pState, pbResult)
    }
    pub unsafe fn SymCryptHmacSha256ExpandKey(
        &self,
        pExpandedKey: PSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptHmacSha256ExpandKey
            .as_ref()
            .expect("Expected function, got error."))(pExpandedKey, pbKey, cbKey)
    }
    pub unsafe fn SymCryptHmacSha256(
        &self,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    ) {
        (self
            .SymCryptHmacSha256
            .as_ref()
            .expect("Expected function, got error."))(pExpandedKey, pbData, cbData, pbResult)
    }
    pub unsafe fn SymCryptHmacSha256StateCopy(
        &self,
        pSrc: PCSYMCRYPT_HMAC_SHA256_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA256_STATE,
    ) {
        (self
            .SymCryptHmacSha256StateCopy
            .as_ref()
            .expect("Expected function, got error."))(pSrc, pExpandedKey, pDst)
    }
    pub unsafe fn SymCryptHmacSha256Init(
        &self,
        pState: PSYMCRYPT_HMAC_SHA256_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
    ) {
        (self
            .SymCryptHmacSha256Init
            .as_ref()
            .expect("Expected function, got error."))(pState, pExpandedKey)
    }
    pub unsafe fn SymCryptHmacSha256Append(
        &self,
        pState: PSYMCRYPT_HMAC_SHA256_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    ) {
        (self
            .SymCryptHmacSha256Append
            .as_ref()
            .expect("Expected function, got error."))(pState, pbData, cbData)
    }
    pub unsafe fn SymCryptHmacSha256Result(
        &self,
        pState: PSYMCRYPT_HMAC_SHA256_STATE,
        pbResult: PBYTE,
    ) {
        (self
            .SymCryptHmacSha256Result
            .as_ref()
            .expect("Expected function, got error."))(pState, pbResult)
    }
    pub unsafe fn SymCryptHmacSha384ExpandKey(
        &self,
        pExpandedKey: PSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptHmacSha384ExpandKey
            .as_ref()
            .expect("Expected function, got error."))(pExpandedKey, pbKey, cbKey)
    }
    pub unsafe fn SymCryptHmacSha384(
        &self,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    ) {
        (self
            .SymCryptHmacSha384
            .as_ref()
            .expect("Expected function, got error."))(pExpandedKey, pbData, cbData, pbResult)
    }
    pub unsafe fn SymCryptHmacSha384StateCopy(
        &self,
        pSrc: PCSYMCRYPT_HMAC_SHA384_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA384_STATE,
    ) {
        (self
            .SymCryptHmacSha384StateCopy
            .as_ref()
            .expect("Expected function, got error."))(pSrc, pExpandedKey, pDst)
    }
    pub unsafe fn SymCryptHmacSha384Init(
        &self,
        pState: PSYMCRYPT_HMAC_SHA384_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
    ) {
        (self
            .SymCryptHmacSha384Init
            .as_ref()
            .expect("Expected function, got error."))(pState, pExpandedKey)
    }
    pub unsafe fn SymCryptHmacSha384Append(
        &self,
        pState: PSYMCRYPT_HMAC_SHA384_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    ) {
        (self
            .SymCryptHmacSha384Append
            .as_ref()
            .expect("Expected function, got error."))(pState, pbData, cbData)
    }
    pub unsafe fn SymCryptHmacSha384Result(
        &self,
        pState: PSYMCRYPT_HMAC_SHA384_STATE,
        pbResult: PBYTE,
    ) {
        (self
            .SymCryptHmacSha384Result
            .as_ref()
            .expect("Expected function, got error."))(pState, pbResult)
    }
    pub unsafe fn SymCryptHmacSha512ExpandKey(
        &self,
        pExpandedKey: PSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptHmacSha512ExpandKey
            .as_ref()
            .expect("Expected function, got error."))(pExpandedKey, pbKey, cbKey)
    }
    pub unsafe fn SymCryptHmacSha512(
        &self,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    ) {
        (self
            .SymCryptHmacSha512
            .as_ref()
            .expect("Expected function, got error."))(pExpandedKey, pbData, cbData, pbResult)
    }
    pub unsafe fn SymCryptHmacSha512StateCopy(
        &self,
        pSrc: PCSYMCRYPT_HMAC_SHA512_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA512_STATE,
    ) {
        (self
            .SymCryptHmacSha512StateCopy
            .as_ref()
            .expect("Expected function, got error."))(pSrc, pExpandedKey, pDst)
    }
    pub unsafe fn SymCryptHmacSha512Init(
        &self,
        pState: PSYMCRYPT_HMAC_SHA512_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
    ) {
        (self
            .SymCryptHmacSha512Init
            .as_ref()
            .expect("Expected function, got error."))(pState, pExpandedKey)
    }
    pub unsafe fn SymCryptHmacSha512Append(
        &self,
        pState: PSYMCRYPT_HMAC_SHA512_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    ) {
        (self
            .SymCryptHmacSha512Append
            .as_ref()
            .expect("Expected function, got error."))(pState, pbData, cbData)
    }
    pub unsafe fn SymCryptHmacSha512Result(
        &self,
        pState: PSYMCRYPT_HMAC_SHA512_STATE,
        pbResult: PBYTE,
    ) {
        (self
            .SymCryptHmacSha512Result
            .as_ref()
            .expect("Expected function, got error."))(pState, pbResult)
    }
    pub unsafe fn SymCryptChaCha20Poly1305Encrypt(
        &self,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptChaCha20Poly1305Encrypt
            .as_ref()
            .expect("Expected function, got error."))(
            pbKey, cbKey, pbNonce, cbNonce, pbAuthData, cbAuthData, pbSrc, pbDst, cbData, pbTag,
            cbTag,
        )
    }
    pub unsafe fn SymCryptChaCha20Poly1305Decrypt(
        &self,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PCBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptChaCha20Poly1305Decrypt
            .as_ref()
            .expect("Expected function, got error."))(
            pbKey, cbKey, pbNonce, cbNonce, pbAuthData, cbAuthData, pbSrc, pbDst, cbData, pbTag,
            cbTag,
        )
    }
    pub unsafe fn SymCryptGcmValidateParameters(
        &self,
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        cbNonce: SIZE_T,
        cbAssociatedData: UINT64,
        cbData: UINT64,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptGcmValidateParameters
            .as_ref()
            .expect("Expected function, got error."))(
            pBlockCipher,
            cbNonce,
            cbAssociatedData,
            cbData,
            cbTag,
        )
    }
    pub unsafe fn SymCryptGcmExpandKey(
        &self,
        pExpandedKey: PSYMCRYPT_GCM_EXPANDED_KEY,
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptGcmExpandKey
            .as_ref()
            .expect("Expected function, got error."))(
            pExpandedKey, pBlockCipher, pbKey, cbKey
        )
    }
    pub unsafe fn SymCryptGcmEncrypt(
        &self,
        pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PBYTE,
        cbTag: SIZE_T,
    ) {
        (self
            .SymCryptGcmEncrypt
            .as_ref()
            .expect("Expected function, got error."))(
            pExpandedKey,
            pbNonce,
            cbNonce,
            pbAuthData,
            cbAuthData,
            pbSrc,
            pbDst,
            cbData,
            pbTag,
            cbTag,
        )
    }
    pub unsafe fn SymCryptGcmDecrypt(
        &self,
        pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PCBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptGcmDecrypt
            .as_ref()
            .expect("Expected function, got error."))(
            pExpandedKey,
            pbNonce,
            cbNonce,
            pbAuthData,
            cbAuthData,
            pbSrc,
            pbDst,
            cbData,
            pbTag,
            cbTag,
        )
    }
    pub unsafe fn SymCryptGcmInit(
        &self,
        pState: PSYMCRYPT_GCM_STATE,
        pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
    ) {
        (self
            .SymCryptGcmInit
            .as_ref()
            .expect("Expected function, got error."))(pState, pExpandedKey, pbNonce, cbNonce)
    }
    pub unsafe fn SymCryptGcmStateCopy(
        &self,
        pSrc: PCSYMCRYPT_GCM_STATE,
        pExpandedKeyCopy: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pDst: PSYMCRYPT_GCM_STATE,
    ) {
        (self
            .SymCryptGcmStateCopy
            .as_ref()
            .expect("Expected function, got error."))(pSrc, pExpandedKeyCopy, pDst)
    }
    pub unsafe fn SymCryptGcmAuthPart(
        &self,
        pState: PSYMCRYPT_GCM_STATE,
        pbAuthData: PCBYTE,
        cbData: SIZE_T,
    ) {
        (self
            .SymCryptGcmAuthPart
            .as_ref()
            .expect("Expected function, got error."))(pState, pbAuthData, cbData)
    }
    pub unsafe fn SymCryptGcmEncryptPart(
        &self,
        pState: PSYMCRYPT_GCM_STATE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    ) {
        (self
            .SymCryptGcmEncryptPart
            .as_ref()
            .expect("Expected function, got error."))(pState, pbSrc, pbDst, cbData)
    }
    pub unsafe fn SymCryptGcmEncryptFinal(
        &self,
        pState: PSYMCRYPT_GCM_STATE,
        pbTag: PBYTE,
        cbTag: SIZE_T,
    ) {
        (self
            .SymCryptGcmEncryptFinal
            .as_ref()
            .expect("Expected function, got error."))(pState, pbTag, cbTag)
    }
    pub unsafe fn SymCryptGcmDecryptPart(
        &self,
        pState: PSYMCRYPT_GCM_STATE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    ) {
        (self
            .SymCryptGcmDecryptPart
            .as_ref()
            .expect("Expected function, got error."))(pState, pbSrc, pbDst, cbData)
    }
    pub unsafe fn SymCryptGcmDecryptFinal(
        &self,
        pState: PSYMCRYPT_GCM_STATE,
        pbTag: PCBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptGcmDecryptFinal
            .as_ref()
            .expect("Expected function, got error."))(pState, pbTag, cbTag)
    }
    pub unsafe fn SymCryptTlsPrf1_2ExpandKey(
        &self,
        pExpandedKey: PSYMCRYPT_TLSPRF1_2_EXPANDED_KEY,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptTlsPrf1_2ExpandKey
            .as_ref()
            .expect("Expected function, got error."))(
            pExpandedKey, macAlgorithm, pbKey, cbKey
        )
    }
    pub unsafe fn SymCryptTlsPrf1_2Derive(
        &self,
        pExpandedKey: PCSYMCRYPT_TLSPRF1_2_EXPANDED_KEY,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        pbSeed: PCBYTE,
        cbSeed: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptTlsPrf1_2Derive
            .as_ref()
            .expect("Expected function, got error."))(
            pExpandedKey,
            pbLabel,
            cbLabel,
            pbSeed,
            cbSeed,
            pbResult,
            cbResult,
        )
    }
    pub unsafe fn SymCryptTlsPrf1_2(
        &self,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        pbSeed: PCBYTE,
        cbSeed: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptTlsPrf1_2
            .as_ref()
            .expect("Expected function, got error."))(
            macAlgorithm,
            pbKey,
            cbKey,
            pbLabel,
            cbLabel,
            pbSeed,
            cbSeed,
            pbResult,
            cbResult,
        )
    }
    pub unsafe fn SymCryptHkdfExpandKey(
        &self,
        pExpandedKey: PSYMCRYPT_HKDF_EXPANDED_KEY,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbIkm: PCBYTE,
        cbIkm: SIZE_T,
        pbSalt: PCBYTE,
        cbSalt: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptHkdfExpandKey
            .as_ref()
            .expect("Expected function, got error."))(
            pExpandedKey,
            macAlgorithm,
            pbIkm,
            cbIkm,
            pbSalt,
            cbSalt,
        )
    }
    pub unsafe fn SymCryptHkdfExtractPrk(
        &self,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbIkm: PCBYTE,
        cbIkm: SIZE_T,
        pbSalt: PCBYTE,
        cbSalt: SIZE_T,
        pbPrk: PBYTE,
        cbPrk: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptHkdfExtractPrk
            .as_ref()
            .expect("Expected function, got error."))(
            macAlgorithm,
            pbIkm,
            cbIkm,
            pbSalt,
            cbSalt,
            pbPrk,
            cbPrk,
        )
    }
    pub unsafe fn SymCryptHkdfPrkExpandKey(
        &self,
        pExpandedKey: PSYMCRYPT_HKDF_EXPANDED_KEY,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbPrk: PCBYTE,
        cbPrk: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptHkdfPrkExpandKey
            .as_ref()
            .expect("Expected function, got error."))(
            pExpandedKey, macAlgorithm, pbPrk, cbPrk
        )
    }
    pub unsafe fn SymCryptHkdfDerive(
        &self,
        pExpandedKey: PCSYMCRYPT_HKDF_EXPANDED_KEY,
        pbInfo: PCBYTE,
        cbInfo: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptHkdfDerive
            .as_ref()
            .expect("Expected function, got error."))(
            pExpandedKey,
            pbInfo,
            cbInfo,
            pbResult,
            cbResult,
        )
    }
    pub unsafe fn SymCryptHkdf(
        &self,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbIkm: PCBYTE,
        cbIkm: SIZE_T,
        pbSalt: PCBYTE,
        cbSalt: SIZE_T,
        pbInfo: PCBYTE,
        cbInfo: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptHkdf
            .as_ref()
            .expect("Expected function, got error."))(
            macAlgorithm,
            pbIkm,
            cbIkm,
            pbSalt,
            cbSalt,
            pbInfo,
            cbInfo,
            pbResult,
            cbResult,
        )
    }
    pub unsafe fn SymCryptHkdfSelfTest(&self) {
        (self
            .SymCryptHkdfSelfTest
            .as_ref()
            .expect("Expected function, got error."))()
    }
    pub unsafe fn SymCryptRandom(&self, pbRandom: PBYTE, cbRandom: SIZE_T) {
        (self
            .SymCryptRandom
            .as_ref()
            .expect("Expected function, got error."))(pbRandom, cbRandom)
    }
    pub unsafe fn SymCryptRsakeyAllocate(
        &self,
        pParams: PCSYMCRYPT_RSA_PARAMS,
        flags: UINT32,
    ) -> PSYMCRYPT_RSAKEY {
        (self
            .SymCryptRsakeyAllocate
            .as_ref()
            .expect("Expected function, got error."))(pParams, flags)
    }
    pub unsafe fn SymCryptRsakeyFree(&self, pkObj: PSYMCRYPT_RSAKEY) {
        (self
            .SymCryptRsakeyFree
            .as_ref()
            .expect("Expected function, got error."))(pkObj)
    }
    pub unsafe fn SymCryptEcurveAllocate(
        &self,
        pParams: PCSYMCRYPT_ECURVE_PARAMS,
        flags: UINT32,
    ) -> PSYMCRYPT_ECURVE {
        (self
            .SymCryptEcurveAllocate
            .as_ref()
            .expect("Expected function, got error."))(pParams, flags)
    }
    pub unsafe fn SymCryptEcurveFree(&self, pCurve: PSYMCRYPT_ECURVE) {
        (self
            .SymCryptEcurveFree
            .as_ref()
            .expect("Expected function, got error."))(pCurve)
    }
    pub unsafe fn SymCryptEckeyAllocate(&self, pCurve: PCSYMCRYPT_ECURVE) -> PSYMCRYPT_ECKEY {
        (self
            .SymCryptEckeyAllocate
            .as_ref()
            .expect("Expected function, got error."))(pCurve)
    }
    pub unsafe fn SymCryptEckeyFree(&self, pkObj: PSYMCRYPT_ECKEY) {
        (self
            .SymCryptEckeyFree
            .as_ref()
            .expect("Expected function, got error."))(pkObj)
    }
    pub unsafe fn SymCryptRsakeyHasPrivateKey(&self, pkRsakey: PCSYMCRYPT_RSAKEY) -> BOOLEAN {
        (self
            .SymCryptRsakeyHasPrivateKey
            .as_ref()
            .expect("Expected function, got error."))(pkRsakey)
    }
    pub unsafe fn SymCryptRsakeySizeofModulus(&self, pkRsakey: PCSYMCRYPT_RSAKEY) -> UINT32 {
        (self
            .SymCryptRsakeySizeofModulus
            .as_ref()
            .expect("Expected function, got error."))(pkRsakey)
    }
    pub unsafe fn SymCryptRsakeyModulusBits(&self, pkRsakey: PCSYMCRYPT_RSAKEY) -> UINT32 {
        (self
            .SymCryptRsakeyModulusBits
            .as_ref()
            .expect("Expected function, got error."))(pkRsakey)
    }
    pub unsafe fn SymCryptRsakeySizeofPublicExponent(
        &self,
        pRsakey: PCSYMCRYPT_RSAKEY,
        index: UINT32,
    ) -> UINT32 {
        (self
            .SymCryptRsakeySizeofPublicExponent
            .as_ref()
            .expect("Expected function, got error."))(pRsakey, index)
    }
    pub unsafe fn SymCryptRsakeySizeofPrime(
        &self,
        pkRsakey: PCSYMCRYPT_RSAKEY,
        index: UINT32,
    ) -> UINT32 {
        (self
            .SymCryptRsakeySizeofPrime
            .as_ref()
            .expect("Expected function, got error."))(pkRsakey, index)
    }
    pub unsafe fn SymCryptRsakeyGetNumberOfPublicExponents(
        &self,
        pkRsakey: PCSYMCRYPT_RSAKEY,
    ) -> UINT32 {
        (self
            .SymCryptRsakeyGetNumberOfPublicExponents
            .as_ref()
            .expect("Expected function, got error."))(pkRsakey)
    }
    pub unsafe fn SymCryptRsakeyGetNumberOfPrimes(&self, pkRsakey: PCSYMCRYPT_RSAKEY) -> UINT32 {
        (self
            .SymCryptRsakeyGetNumberOfPrimes
            .as_ref()
            .expect("Expected function, got error."))(pkRsakey)
    }
    pub unsafe fn SymCryptRsakeyGenerate(
        &self,
        pkRsakey: PSYMCRYPT_RSAKEY,
        pu64PubExp: PCUINT64,
        nPubExp: UINT32,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptRsakeyGenerate
            .as_ref()
            .expect("Expected function, got error."))(pkRsakey, pu64PubExp, nPubExp, flags)
    }
    pub unsafe fn SymCryptRsakeySetValue(
        &self,
        pbModulus: PCBYTE,
        cbModulus: SIZE_T,
        pu64PubExp: PCUINT64,
        nPubExp: UINT32,
        ppPrimes: *mut PCBYTE,
        pcbPrimes: *mut SIZE_T,
        nPrimes: UINT32,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pkRsakey: PSYMCRYPT_RSAKEY,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptRsakeySetValue
            .as_ref()
            .expect("Expected function, got error."))(
            pbModulus, cbModulus, pu64PubExp, nPubExp, ppPrimes, pcbPrimes, nPrimes, numFormat,
            flags, pkRsakey,
        )
    }
    pub unsafe fn SymCryptRsakeyGetValue(
        &self,
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbModulus: PBYTE,
        cbModulus: SIZE_T,
        pu64PubExp: PUINT64,
        nPubExp: UINT32,
        ppPrimes: *mut PBYTE,
        pcbPrimes: *mut SIZE_T,
        nPrimes: UINT32,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptRsakeyGetValue
            .as_ref()
            .expect("Expected function, got error."))(
            pkRsakey, pbModulus, cbModulus, pu64PubExp, nPubExp, ppPrimes, pcbPrimes, nPrimes,
            numFormat, flags,
        )
    }
    pub unsafe fn SymCryptRsakeyGetCrtValue(
        &self,
        pkRsakey: PCSYMCRYPT_RSAKEY,
        ppCrtExponents: *mut PBYTE,
        pcbCrtExponents: *mut SIZE_T,
        nCrtExponents: UINT32,
        pbCrtCoefficient: PBYTE,
        cbCrtCoefficient: SIZE_T,
        pbPrivateExponent: PBYTE,
        cbPrivateExponent: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptRsakeyGetCrtValue
            .as_ref()
            .expect("Expected function, got error."))(
            pkRsakey,
            ppCrtExponents,
            pcbCrtExponents,
            nCrtExponents,
            pbCrtCoefficient,
            cbCrtCoefficient,
            pbPrivateExponent,
            cbPrivateExponent,
            numFormat,
            flags,
        )
    }
    pub unsafe fn SymCryptRsakeyExtendKeyUsage(
        &self,
        pkRsakey: PSYMCRYPT_RSAKEY,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptRsakeyExtendKeyUsage
            .as_ref()
            .expect("Expected function, got error."))(pkRsakey, flags)
    }
    pub unsafe fn SymCryptEcurveSizeofFieldElement(&self, pCurve: PCSYMCRYPT_ECURVE) -> UINT32 {
        (self
            .SymCryptEcurveSizeofFieldElement
            .as_ref()
            .expect("Expected function, got error."))(pCurve)
    }
    pub unsafe fn SymCryptEckeySizeofPublicKey(
        &self,
        pkEckey: PCSYMCRYPT_ECKEY,
        ecPointFormat: SYMCRYPT_ECPOINT_FORMAT,
    ) -> UINT32 {
        (self
            .SymCryptEckeySizeofPublicKey
            .as_ref()
            .expect("Expected function, got error."))(pkEckey, ecPointFormat)
    }
    pub unsafe fn SymCryptEckeySizeofPrivateKey(&self, pkEckey: PCSYMCRYPT_ECKEY) -> UINT32 {
        (self
            .SymCryptEckeySizeofPrivateKey
            .as_ref()
            .expect("Expected function, got error."))(pkEckey)
    }
    pub unsafe fn SymCryptEckeySetValue(
        &self,
        pbPrivateKey: PCBYTE,
        cbPrivateKey: SIZE_T,
        pbPublicKey: PCBYTE,
        cbPublicKey: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        ecPointFormat: SYMCRYPT_ECPOINT_FORMAT,
        flags: UINT32,
        pEckey: PSYMCRYPT_ECKEY,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptEckeySetValue
            .as_ref()
            .expect("Expected function, got error."))(
            pbPrivateKey,
            cbPrivateKey,
            pbPublicKey,
            cbPublicKey,
            numFormat,
            ecPointFormat,
            flags,
            pEckey,
        )
    }
    pub unsafe fn SymCryptEckeySetRandom(
        &self,
        flags: UINT32,
        pEckey: PSYMCRYPT_ECKEY,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptEckeySetRandom
            .as_ref()
            .expect("Expected function, got error."))(flags, pEckey)
    }
    pub unsafe fn SymCryptEckeyGetValue(
        &self,
        pEckey: PCSYMCRYPT_ECKEY,
        pbPrivateKey: PBYTE,
        cbPrivateKey: SIZE_T,
        pbPublicKey: PBYTE,
        cbPublicKey: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        ecPointFormat: SYMCRYPT_ECPOINT_FORMAT,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptEckeyGetValue
            .as_ref()
            .expect("Expected function, got error."))(
            pEckey,
            pbPrivateKey,
            cbPrivateKey,
            pbPublicKey,
            cbPublicKey,
            numFormat,
            ecPointFormat,
            flags,
        )
    }
    pub unsafe fn SymCryptRsaPkcs1Encrypt(
        &self,
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        flags: UINT32,
        nfDst: SYMCRYPT_NUMBER_FORMAT,
        pbDst: PBYTE,
        cbDst: SIZE_T,
        pcbDst: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptRsaPkcs1Encrypt
            .as_ref()
            .expect("Expected function, got error."))(
            pkRsakey, pbSrc, cbSrc, flags, nfDst, pbDst, cbDst, pcbDst,
        )
    }
    pub unsafe fn SymCryptRsaPkcs1Decrypt(
        &self,
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        nfSrc: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pbDst: PBYTE,
        cbDst: SIZE_T,
        pcbDst: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptRsaPkcs1Decrypt
            .as_ref()
            .expect("Expected function, got error."))(
            pkRsakey, pbSrc, cbSrc, nfSrc, flags, pbDst, cbDst, pcbDst,
        )
    }
    pub unsafe fn SymCryptRsaOaepEncrypt(
        &self,
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        hashAlgorithm: PCSYMCRYPT_HASH,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        flags: UINT32,
        nfDst: SYMCRYPT_NUMBER_FORMAT,
        pbDst: PBYTE,
        cbDst: SIZE_T,
        pcbDst: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptRsaOaepEncrypt
            .as_ref()
            .expect("Expected function, got error."))(
            pkRsakey,
            pbSrc,
            cbSrc,
            hashAlgorithm,
            pbLabel,
            cbLabel,
            flags,
            nfDst,
            pbDst,
            cbDst,
            pcbDst,
        )
    }
    pub unsafe fn SymCryptRsaOaepDecrypt(
        &self,
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        nfSrc: SYMCRYPT_NUMBER_FORMAT,
        hashAlgorithm: PCSYMCRYPT_HASH,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        flags: UINT32,
        pbDst: PBYTE,
        cbDst: SIZE_T,
        pcbDst: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptRsaOaepDecrypt
            .as_ref()
            .expect("Expected function, got error."))(
            pkRsakey,
            pbSrc,
            cbSrc,
            nfSrc,
            hashAlgorithm,
            pbLabel,
            cbLabel,
            flags,
            pbDst,
            cbDst,
            pcbDst,
        )
    }
    pub unsafe fn SymCryptRsaPkcs1Sign(
        &self,
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        pHashOIDs: PCSYMCRYPT_OID,
        nOIDCount: SIZE_T,
        flags: UINT32,
        nfSignature: SYMCRYPT_NUMBER_FORMAT,
        pbSignature: PBYTE,
        cbSignature: SIZE_T,
        pcbSignature: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptRsaPkcs1Sign
            .as_ref()
            .expect("Expected function, got error."))(
            pkRsakey,
            pbHashValue,
            cbHashValue,
            pHashOIDs,
            nOIDCount,
            flags,
            nfSignature,
            pbSignature,
            cbSignature,
            pcbSignature,
        )
    }
    pub unsafe fn SymCryptRsaPkcs1Verify(
        &self,
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        pbSignature: PCBYTE,
        cbSignature: SIZE_T,
        nfSignature: SYMCRYPT_NUMBER_FORMAT,
        pHashOID: PCSYMCRYPT_OID,
        nOIDCount: SIZE_T,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptRsaPkcs1Verify
            .as_ref()
            .expect("Expected function, got error."))(
            pkRsakey,
            pbHashValue,
            cbHashValue,
            pbSignature,
            cbSignature,
            nfSignature,
            pHashOID,
            nOIDCount,
            flags,
        )
    }
    pub unsafe fn SymCryptRsaPssSign(
        &self,
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        hashAlgorithm: PCSYMCRYPT_HASH,
        cbSalt: SIZE_T,
        flags: UINT32,
        nfSignature: SYMCRYPT_NUMBER_FORMAT,
        pbSignature: PBYTE,
        cbSignature: SIZE_T,
        pcbSignature: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptRsaPssSign
            .as_ref()
            .expect("Expected function, got error."))(
            pkRsakey,
            pbHashValue,
            cbHashValue,
            hashAlgorithm,
            cbSalt,
            flags,
            nfSignature,
            pbSignature,
            cbSignature,
            pcbSignature,
        )
    }
    pub unsafe fn SymCryptRsaPssVerify(
        &self,
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        pbSignature: PCBYTE,
        cbSignature: SIZE_T,
        nfSignature: SYMCRYPT_NUMBER_FORMAT,
        hashAlgorithm: PCSYMCRYPT_HASH,
        cbSalt: SIZE_T,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptRsaPssVerify
            .as_ref()
            .expect("Expected function, got error."))(
            pkRsakey,
            pbHashValue,
            cbHashValue,
            pbSignature,
            cbSignature,
            nfSignature,
            hashAlgorithm,
            cbSalt,
            flags,
        )
    }
    pub unsafe fn SymCryptEcDsaSign(
        &self,
        pKey: PCSYMCRYPT_ECKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        format: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pbSignature: PBYTE,
        cbSignature: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptEcDsaSign
            .as_ref()
            .expect("Expected function, got error."))(
            pKey,
            pbHashValue,
            cbHashValue,
            format,
            flags,
            pbSignature,
            cbSignature,
        )
    }
    pub unsafe fn SymCryptEcDsaVerify(
        &self,
        pKey: PCSYMCRYPT_ECKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        pbSignature: PCBYTE,
        cbSignature: SIZE_T,
        format: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptEcDsaVerify
            .as_ref()
            .expect("Expected function, got error."))(
            pKey,
            pbHashValue,
            cbHashValue,
            pbSignature,
            cbSignature,
            format,
            flags,
        )
    }
    pub unsafe fn SymCryptEcDhSecretAgreement(
        &self,
        pkPrivate: PCSYMCRYPT_ECKEY,
        pkPublic: PCSYMCRYPT_ECKEY,
        format: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pbAgreedSecret: PBYTE,
        cbAgreedSecret: SIZE_T,
    ) -> SYMCRYPT_ERROR {
        (self
            .SymCryptEcDhSecretAgreement
            .as_ref()
            .expect("Expected function, got error."))(
            pkPrivate,
            pkPublic,
            format,
            flags,
            pbAgreedSecret,
            cbAgreedSecret,
        )
    }
}
