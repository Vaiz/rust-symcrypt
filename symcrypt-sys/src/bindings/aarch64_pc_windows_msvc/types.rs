/* automatically generated by rust-bindgen 0.71.1 */

pub const SYMCRYPT_ERROR_SYMCRYPT_NO_ERROR: SYMCRYPT_ERROR = 0;
pub const SYMCRYPT_ERROR_SYMCRYPT_UNUSED: SYMCRYPT_ERROR = 32768;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_KEY_SIZE: SYMCRYPT_ERROR = 32769;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_BLOCK_SIZE: SYMCRYPT_ERROR = 32770;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_DATA_SIZE: SYMCRYPT_ERROR = 32771;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_NONCE_SIZE: SYMCRYPT_ERROR = 32772;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_TAG_SIZE: SYMCRYPT_ERROR = 32773;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_ITERATION_COUNT: SYMCRYPT_ERROR = 32774;
pub const SYMCRYPT_ERROR_SYMCRYPT_AUTHENTICATION_FAILURE: SYMCRYPT_ERROR = 32775;
pub const SYMCRYPT_ERROR_SYMCRYPT_EXTERNAL_FAILURE: SYMCRYPT_ERROR = 32776;
pub const SYMCRYPT_ERROR_SYMCRYPT_FIPS_FAILURE: SYMCRYPT_ERROR = 32777;
pub const SYMCRYPT_ERROR_SYMCRYPT_HARDWARE_FAILURE: SYMCRYPT_ERROR = 32778;
pub const SYMCRYPT_ERROR_SYMCRYPT_NOT_IMPLEMENTED: SYMCRYPT_ERROR = 32779;
pub const SYMCRYPT_ERROR_SYMCRYPT_INVALID_BLOB: SYMCRYPT_ERROR = 32780;
pub const SYMCRYPT_ERROR_SYMCRYPT_BUFFER_TOO_SMALL: SYMCRYPT_ERROR = 32781;
pub const SYMCRYPT_ERROR_SYMCRYPT_INVALID_ARGUMENT: SYMCRYPT_ERROR = 32782;
pub const SYMCRYPT_ERROR_SYMCRYPT_MEMORY_ALLOCATION_FAILURE: SYMCRYPT_ERROR = 32783;
pub const SYMCRYPT_ERROR_SYMCRYPT_SIGNATURE_VERIFICATION_FAILURE: SYMCRYPT_ERROR = 32784;
pub const SYMCRYPT_ERROR_SYMCRYPT_INCOMPATIBLE_FORMAT: SYMCRYPT_ERROR = 32785;
pub const SYMCRYPT_ERROR_SYMCRYPT_VALUE_TOO_LARGE: SYMCRYPT_ERROR = 32786;
pub const SYMCRYPT_ERROR_SYMCRYPT_SESSION_REPLAY_FAILURE: SYMCRYPT_ERROR = 32787;
pub const SYMCRYPT_ERROR_SYMCRYPT_HBS_NO_OTS_KEYS_LEFT: SYMCRYPT_ERROR = 32788;
pub const SYMCRYPT_ERROR_SYMCRYPT_HBS_PUBLIC_ROOT_MISMATCH: SYMCRYPT_ERROR = 32789;
pub type SYMCRYPT_ERROR = ::std::os::raw::c_int;
pub const _SYMCRYPT_ECURVE_TYPE_SYMCRYPT_ECURVE_TYPE_NULL: _SYMCRYPT_ECURVE_TYPE = 0;
pub const _SYMCRYPT_ECURVE_TYPE_SYMCRYPT_ECURVE_TYPE_SHORT_WEIERSTRASS: _SYMCRYPT_ECURVE_TYPE = 1;
pub const _SYMCRYPT_ECURVE_TYPE_SYMCRYPT_ECURVE_TYPE_TWISTED_EDWARDS: _SYMCRYPT_ECURVE_TYPE = 2;
pub const _SYMCRYPT_ECURVE_TYPE_SYMCRYPT_ECURVE_TYPE_MONTGOMERY: _SYMCRYPT_ECURVE_TYPE = 3;
pub type _SYMCRYPT_ECURVE_TYPE = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_ECURVE_TYPE as SYMCRYPT_ECURVE_TYPE;
pub const _SYMCRYPT_DLGROUP_FIPS_SYMCRYPT_DLGROUP_FIPS_NONE: _SYMCRYPT_DLGROUP_FIPS = 0;
pub const _SYMCRYPT_DLGROUP_FIPS_SYMCRYPT_DLGROUP_FIPS_186_2: _SYMCRYPT_DLGROUP_FIPS = 1;
pub const _SYMCRYPT_DLGROUP_FIPS_SYMCRYPT_DLGROUP_FIPS_186_3: _SYMCRYPT_DLGROUP_FIPS = 2;
pub type _SYMCRYPT_DLGROUP_FIPS = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_DLGROUP_FIPS as SYMCRYPT_DLGROUP_FIPS;
pub const _SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_NONE:
    _SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE = 0;
pub const _SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_IKE_3526:
    _SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE = 1;
pub const _SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_TLS_7919:
    _SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE = 2;
pub type _SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE as SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE;
pub type CHAR = ::std::os::raw::c_char;
pub type INT8 = ::std::os::raw::c_schar;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type BYTE = ::std::os::raw::c_uchar;
pub type SHORT = ::std::os::raw::c_short;
pub type INT16 = ::std::os::raw::c_short;
pub type USHORT = ::std::os::raw::c_ushort;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type WORD = ::std::os::raw::c_ushort;
pub type INT = ::std::os::raw::c_int;
pub type INT32 = ::std::os::raw::c_int;
pub type UINT = ::std::os::raw::c_uint;
pub type UINT32 = ::std::os::raw::c_uint;
pub type LONG = ::std::os::raw::c_long;
pub type ULONG = ::std::os::raw::c_ulong;
pub type DWORD = ::std::os::raw::c_ulong;
pub type LONGLONG = ::std::os::raw::c_longlong;
pub type LONG64 = ::std::os::raw::c_longlong;
pub type INT64 = ::std::os::raw::c_longlong;
pub type ULONGLONG = ::std::os::raw::c_ulonglong;
pub type DWORDLONG = ::std::os::raw::c_ulonglong;
pub type ULONG64 = ::std::os::raw::c_ulonglong;
pub type DWORD64 = ::std::os::raw::c_ulonglong;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type INT_PTR = ::std::os::raw::c_longlong;
pub type UINT_PTR = ::std::os::raw::c_ulonglong;
pub type LONG_PTR = ::std::os::raw::c_longlong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type DWORD_PTR = ULONG_PTR;
pub type SSIZE_T = LONG_PTR;
pub type SIZE_T = ULONG_PTR;
pub type HRESULT = ::std::os::raw::c_long;
pub type __C_ASSERT__ = [::std::os::raw::c_char; 1usize];
pub type va_list = *mut ::std::os::raw::c_char;
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type __crt_bool = bool;
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
impl Default for __crt_locale_data_public {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
impl Default for __crt_locale_pointers {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
pub type PBYTE = *mut BYTE;
pub type PCBYTE = *const BYTE;
pub type PUINT16 = *mut UINT16;
pub type PCUINT16 = *const UINT16;
pub type PUINT32 = *mut UINT32;
pub type PCUINT32 = *const UINT32;
pub type PUINT64 = *mut UINT64;
pub type PCUINT64 = *const UINT64;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type PCVOID = *const ::std::os::raw::c_void;
pub type BOOLEAN = BYTE;
pub type SYMCRYPT_CPU_FEATURES = UINT32;
pub type SYMCRYPT_BLOCKCIPHER = _SYMCRYPT_BLOCKCIPHER;
pub type PSYMCRYPT_BLOCKCIPHER = *mut _SYMCRYPT_BLOCKCIPHER;
pub type PCSYMCRYPT_BLOCKCIPHER = *const SYMCRYPT_BLOCKCIPHER;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_COMMON_HASH_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 1usize],
}
pub type SYMCRYPT_COMMON_HASH_STATE = _SYMCRYPT_COMMON_HASH_STATE;
pub type PSYMCRYPT_COMMON_HASH_STATE = *mut _SYMCRYPT_COMMON_HASH_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_MD2_CHAINING_STATE {
    pub C: [BYTE; 16usize],
    pub X: [BYTE; 48usize],
}
impl Default for _SYMCRYPT_MD2_CHAINING_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_MD2_CHAINING_STATE = _SYMCRYPT_MD2_CHAINING_STATE;
pub type PSYMCRYPT_MD2_CHAINING_STATE = *mut _SYMCRYPT_MD2_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_MD2_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 16usize],
    pub chain: SYMCRYPT_MD2_CHAINING_STATE,
}
impl Default for _SYMCRYPT_MD2_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_MD2_STATE = _SYMCRYPT_MD2_STATE;
pub type PSYMCRYPT_MD2_STATE = *mut _SYMCRYPT_MD2_STATE;
pub type PCSYMCRYPT_MD2_STATE = *const SYMCRYPT_MD2_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_MD4_CHAINING_STATE {
    pub H: [UINT32; 4usize],
}
pub type SYMCRYPT_MD4_CHAINING_STATE = _SYMCRYPT_MD4_CHAINING_STATE;
pub type PSYMCRYPT_MD4_CHAINING_STATE = *mut _SYMCRYPT_MD4_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_MD4_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 64usize],
    pub chain: SYMCRYPT_MD4_CHAINING_STATE,
}
impl Default for _SYMCRYPT_MD4_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_MD4_STATE = _SYMCRYPT_MD4_STATE;
pub type PSYMCRYPT_MD4_STATE = *mut _SYMCRYPT_MD4_STATE;
pub type PCSYMCRYPT_MD4_STATE = *const SYMCRYPT_MD4_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_MD5_CHAINING_STATE {
    pub H: [UINT32; 4usize],
}
pub type SYMCRYPT_MD5_CHAINING_STATE = _SYMCRYPT_MD5_CHAINING_STATE;
pub type PSYMCRYPT_MD5_CHAINING_STATE = *mut _SYMCRYPT_MD5_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_MD5_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 64usize],
    pub chain: SYMCRYPT_MD5_CHAINING_STATE,
}
impl Default for _SYMCRYPT_MD5_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_MD5_STATE = _SYMCRYPT_MD5_STATE;
pub type PSYMCRYPT_MD5_STATE = *mut _SYMCRYPT_MD5_STATE;
pub type PCSYMCRYPT_MD5_STATE = *const SYMCRYPT_MD5_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SHA1_CHAINING_STATE {
    pub H: [UINT32; 5usize],
}
pub type SYMCRYPT_SHA1_CHAINING_STATE = _SYMCRYPT_SHA1_CHAINING_STATE;
pub type PSYMCRYPT_SHA1_CHAINING_STATE = *mut _SYMCRYPT_SHA1_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SHA1_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 64usize],
    pub chain: SYMCRYPT_SHA1_CHAINING_STATE,
}
impl Default for _SYMCRYPT_SHA1_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SHA1_STATE = _SYMCRYPT_SHA1_STATE;
pub type PSYMCRYPT_SHA1_STATE = *mut _SYMCRYPT_SHA1_STATE;
pub type PCSYMCRYPT_SHA1_STATE = *const SYMCRYPT_SHA1_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SHA256_CHAINING_STATE {
    pub H: [UINT32; 8usize],
}
pub type SYMCRYPT_SHA256_CHAINING_STATE = _SYMCRYPT_SHA256_CHAINING_STATE;
pub type PSYMCRYPT_SHA256_CHAINING_STATE = *mut _SYMCRYPT_SHA256_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SHA256_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 64usize],
    pub chain: SYMCRYPT_SHA256_CHAINING_STATE,
}
impl Default for _SYMCRYPT_SHA256_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SHA256_STATE = _SYMCRYPT_SHA256_STATE;
pub type PSYMCRYPT_SHA256_STATE = *mut _SYMCRYPT_SHA256_STATE;
pub type PCSYMCRYPT_SHA256_STATE = *const SYMCRYPT_SHA256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SHA224_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 64usize],
    pub chain: SYMCRYPT_SHA256_CHAINING_STATE,
}
impl Default for _SYMCRYPT_SHA224_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SHA224_STATE = _SYMCRYPT_SHA224_STATE;
pub type PSYMCRYPT_SHA224_STATE = *mut _SYMCRYPT_SHA224_STATE;
pub type PCSYMCRYPT_SHA224_STATE = *const SYMCRYPT_SHA224_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SHA512_CHAINING_STATE {
    pub H: [UINT64; 8usize],
}
pub type SYMCRYPT_SHA512_CHAINING_STATE = _SYMCRYPT_SHA512_CHAINING_STATE;
pub type PSYMCRYPT_SHA512_CHAINING_STATE = *mut _SYMCRYPT_SHA512_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SHA512_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 128usize],
    pub chain: SYMCRYPT_SHA512_CHAINING_STATE,
}
impl Default for _SYMCRYPT_SHA512_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SHA512_STATE = _SYMCRYPT_SHA512_STATE;
pub type PSYMCRYPT_SHA512_STATE = *mut _SYMCRYPT_SHA512_STATE;
pub type PCSYMCRYPT_SHA512_STATE = *const SYMCRYPT_SHA512_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SHA384_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 128usize],
    pub chain: SYMCRYPT_SHA512_CHAINING_STATE,
}
impl Default for _SYMCRYPT_SHA384_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SHA384_STATE = _SYMCRYPT_SHA384_STATE;
pub type PSYMCRYPT_SHA384_STATE = *mut _SYMCRYPT_SHA384_STATE;
pub type PCSYMCRYPT_SHA384_STATE = *const SYMCRYPT_SHA384_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SHA512_224_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 128usize],
    pub chain: SYMCRYPT_SHA512_CHAINING_STATE,
}
impl Default for _SYMCRYPT_SHA512_224_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SHA512_224_STATE = _SYMCRYPT_SHA512_224_STATE;
pub type PSYMCRYPT_SHA512_224_STATE = *mut _SYMCRYPT_SHA512_224_STATE;
pub type PCSYMCRYPT_SHA512_224_STATE = *const SYMCRYPT_SHA512_224_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SHA512_256_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 128usize],
    pub chain: SYMCRYPT_SHA512_CHAINING_STATE,
}
impl Default for _SYMCRYPT_SHA512_256_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SHA512_256_STATE = _SYMCRYPT_SHA512_256_STATE;
pub type PSYMCRYPT_SHA512_256_STATE = *mut _SYMCRYPT_SHA512_256_STATE;
pub type PCSYMCRYPT_SHA512_256_STATE = *const SYMCRYPT_SHA512_256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_KECCAK_STATE {
    pub state: [UINT64; 25usize],
    pub inputBlockSize: UINT32,
    pub stateIndex: UINT32,
    pub paddingValue: UINT8,
    pub squeezeMode: BOOLEAN,
}
pub type SYMCRYPT_KECCAK_STATE = _SYMCRYPT_KECCAK_STATE;
pub type PSYMCRYPT_KECCAK_STATE = *mut _SYMCRYPT_KECCAK_STATE;
pub type PCSYMCRYPT_KECCAK_STATE = *const SYMCRYPT_KECCAK_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SHA3_224_STATE {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_SHA3_224_STATE = _SYMCRYPT_SHA3_224_STATE;
pub type PSYMCRYPT_SHA3_224_STATE = *mut _SYMCRYPT_SHA3_224_STATE;
pub type PCSYMCRYPT_SHA3_224_STATE = *const SYMCRYPT_SHA3_224_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SHA3_256_STATE {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_SHA3_256_STATE = _SYMCRYPT_SHA3_256_STATE;
pub type PSYMCRYPT_SHA3_256_STATE = *mut _SYMCRYPT_SHA3_256_STATE;
pub type PCSYMCRYPT_SHA3_256_STATE = *const SYMCRYPT_SHA3_256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SHA3_384_STATE {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_SHA3_384_STATE = _SYMCRYPT_SHA3_384_STATE;
pub type PSYMCRYPT_SHA3_384_STATE = *mut _SYMCRYPT_SHA3_384_STATE;
pub type PCSYMCRYPT_SHA3_384_STATE = *const SYMCRYPT_SHA3_384_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SHA3_512_STATE {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_SHA3_512_STATE = _SYMCRYPT_SHA3_512_STATE;
pub type PSYMCRYPT_SHA3_512_STATE = *mut _SYMCRYPT_SHA3_512_STATE;
pub type PCSYMCRYPT_SHA3_512_STATE = *const SYMCRYPT_SHA3_512_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SHAKE128_STATE {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_SHAKE128_STATE = _SYMCRYPT_SHAKE128_STATE;
pub type PSYMCRYPT_SHAKE128_STATE = *mut _SYMCRYPT_SHAKE128_STATE;
pub type PCSYMCRYPT_SHAKE128_STATE = *const SYMCRYPT_SHAKE128_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SHAKE256_STATE {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_SHAKE256_STATE = _SYMCRYPT_SHAKE256_STATE;
pub type PSYMCRYPT_SHAKE256_STATE = *mut _SYMCRYPT_SHAKE256_STATE;
pub type PCSYMCRYPT_SHAKE256_STATE = *const SYMCRYPT_SHAKE256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_CSHAKE128_STATE {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_CSHAKE128_STATE = _SYMCRYPT_CSHAKE128_STATE;
pub type PSYMCRYPT_CSHAKE128_STATE = *mut _SYMCRYPT_CSHAKE128_STATE;
pub type PCSYMCRYPT_CSHAKE128_STATE = *const SYMCRYPT_CSHAKE128_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_CSHAKE256_STATE {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_CSHAKE256_STATE = _SYMCRYPT_CSHAKE256_STATE;
pub type PSYMCRYPT_CSHAKE256_STATE = *mut _SYMCRYPT_CSHAKE256_STATE;
pub type PCSYMCRYPT_CSHAKE256_STATE = *const SYMCRYPT_CSHAKE256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_KMAC128_EXPANDED_KEY {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_KMAC128_EXPANDED_KEY = _SYMCRYPT_KMAC128_EXPANDED_KEY;
pub type PSYMCRYPT_KMAC128_EXPANDED_KEY = *mut _SYMCRYPT_KMAC128_EXPANDED_KEY;
pub type PCSYMCRYPT_KMAC128_EXPANDED_KEY = *const SYMCRYPT_KMAC128_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_KMAC128_STATE {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_KMAC128_STATE = _SYMCRYPT_KMAC128_STATE;
pub type PSYMCRYPT_KMAC128_STATE = *mut _SYMCRYPT_KMAC128_STATE;
pub type PCSYMCRYPT_KMAC128_STATE = *const SYMCRYPT_KMAC128_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_KMAC256_EXPANDED_KEY {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_KMAC256_EXPANDED_KEY = _SYMCRYPT_KMAC256_EXPANDED_KEY;
pub type PSYMCRYPT_KMAC256_EXPANDED_KEY = *mut _SYMCRYPT_KMAC256_EXPANDED_KEY;
pub type PCSYMCRYPT_KMAC256_EXPANDED_KEY = *const SYMCRYPT_KMAC256_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_KMAC256_STATE {
    pub ks: SYMCRYPT_KECCAK_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_KMAC256_STATE = _SYMCRYPT_KMAC256_STATE;
pub type PSYMCRYPT_KMAC256_STATE = *mut _SYMCRYPT_KMAC256_STATE;
pub type PCSYMCRYPT_KMAC256_STATE = *const SYMCRYPT_KMAC256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_HASH_STATE {
    pub md2State: SYMCRYPT_MD2_STATE,
    pub md4State: SYMCRYPT_MD4_STATE,
    pub md5State: SYMCRYPT_MD5_STATE,
    pub sha1State: SYMCRYPT_SHA1_STATE,
    pub sha224State: SYMCRYPT_SHA224_STATE,
    pub sha256State: SYMCRYPT_SHA256_STATE,
    pub sha384State: SYMCRYPT_SHA384_STATE,
    pub sha512State: SYMCRYPT_SHA512_STATE,
    pub sha512_224State: SYMCRYPT_SHA512_224_STATE,
    pub sha512_256State: SYMCRYPT_SHA512_256_STATE,
    pub sha3_224State: SYMCRYPT_SHA3_224_STATE,
    pub sha3_256State: SYMCRYPT_SHA3_256_STATE,
    pub sha3_384State: SYMCRYPT_SHA3_384_STATE,
    pub sha3_512State: SYMCRYPT_SHA3_512_STATE,
}
impl Default for _SYMCRYPT_HASH_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HASH_STATE = _SYMCRYPT_HASH_STATE;
pub type PSYMCRYPT_HASH_STATE = *mut _SYMCRYPT_HASH_STATE;
pub type PCSYMCRYPT_HASH_STATE = *const SYMCRYPT_HASH_STATE;
pub type SYMCRYPT_HASH = _SYMCRYPT_HASH;
pub type PSYMCRYPT_HASH = *mut _SYMCRYPT_HASH;
pub type PCSYMCRYPT_HASH = *const SYMCRYPT_HASH;
pub type SYMCRYPT_PARALLEL_HASH = _SYMCRYPT_PARALLEL_HASH;
pub type PSYMCRYPT_PARALLEL_HASH = *mut _SYMCRYPT_PARALLEL_HASH;
pub type PCSYMCRYPT_PARALLEL_HASH = *const SYMCRYPT_PARALLEL_HASH;
pub type PSYMCRYPT_HASH_INIT_FUNC = ::std::option::Option<unsafe extern "C" fn(pState: PVOID)>;
pub type PSYMCRYPT_HASH_APPEND_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbData: PCBYTE, cbData: SIZE_T)>;
pub type PSYMCRYPT_HASH_RESULT_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbResult: PVOID)>;
pub type PSYMCRYPT_HASH_APPEND_BLOCKS_FUNC = ::std::option::Option<
    unsafe extern "C" fn(pChain: PVOID, pbData: PCBYTE, cbData: SIZE_T, pcbRemaining: *mut SIZE_T),
>;
pub type PSYMCRYPT_HASH_STATE_COPY_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pStateSrc: PCVOID, pStateDst: PVOID)>;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HASH {
    pub initFunc: PSYMCRYPT_HASH_INIT_FUNC,
    pub appendFunc: PSYMCRYPT_HASH_APPEND_FUNC,
    pub resultFunc: PSYMCRYPT_HASH_RESULT_FUNC,
    pub appendBlockFunc: PSYMCRYPT_HASH_APPEND_BLOCKS_FUNC,
    pub stateCopyFunc: PSYMCRYPT_HASH_STATE_COPY_FUNC,
    pub stateSize: UINT32,
    pub resultSize: UINT32,
    pub inputBlockSize: UINT32,
    pub chainOffset: UINT32,
    pub chainSize: UINT32,
}
pub const _SYMCRYPT_HASH_OPERATION_TYPE_SYMCRYPT_HASH_OPERATION_APPEND:
    _SYMCRYPT_HASH_OPERATION_TYPE = 1;
pub const _SYMCRYPT_HASH_OPERATION_TYPE_SYMCRYPT_HASH_OPERATION_RESULT:
    _SYMCRYPT_HASH_OPERATION_TYPE = 2;
pub type _SYMCRYPT_HASH_OPERATION_TYPE = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_HASH_OPERATION_TYPE as SYMCRYPT_HASH_OPERATION_TYPE;
pub type SYMCRYPT_PARALLEL_HASH_OPERATION = _SYMCRYPT_PARALLEL_HASH_OPERATION;
pub type PSYMCRYPT_PARALLEL_HASH_OPERATION = *mut _SYMCRYPT_PARALLEL_HASH_OPERATION;
pub type PCSYMRYPT_PARALLEL_HASH_OPERATION = *const SYMCRYPT_PARALLEL_HASH_OPERATION;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_PARALLEL_HASH_OPERATION {
    pub iHash: SIZE_T,
    pub hashOperation: SYMCRYPT_HASH_OPERATION_TYPE,
    pub pbBuffer: PBYTE,
    pub cbBuffer: SIZE_T,
    pub next: PSYMCRYPT_PARALLEL_HASH_OPERATION,
}
impl Default for _SYMCRYPT_PARALLEL_HASH_OPERATION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_PARALLEL_HASH_SCRATCH_OPERATION {
    _unused: [u8; 0],
}
pub type SYMCRYPT_PARALLEL_HASH_SCRATCH_OPERATION = _SYMCRYPT_PARALLEL_HASH_SCRATCH_OPERATION;
pub type PSYMCRYPT_PARALLEL_HASH_SCRATCH_OPERATION = *mut _SYMCRYPT_PARALLEL_HASH_SCRATCH_OPERATION;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE {
    pub hashState: PVOID,
    pub processingState: BYTE,
    pub bytesAlreadyProcessed: BYTE,
    pub bytes: UINT64,
    pub next: PSYMCRYPT_PARALLEL_HASH_OPERATION,
    pub pbData: PCBYTE,
    pub cbData: SIZE_T,
}
impl Default for _SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE = _SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE;
pub type PSYMCRYPT_PARALLEL_HASH_SCRATCH_STATE = *mut _SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE;
pub type PSYMCRYPT_PARALLEL_HASH_RESULT_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pParHash: PCSYMCRYPT_PARALLEL_HASH,
        pState: PSYMCRYPT_COMMON_HASH_STATE,
        pScratch: PSYMCRYPT_PARALLEL_HASH_SCRATCH_STATE,
        pRes: *mut BOOLEAN,
    ) -> BOOLEAN,
>;
pub type PSYMCRYPT_PARALLEL_HASH_RESULT_DONE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pParHash: PCSYMCRYPT_PARALLEL_HASH,
        pState: PSYMCRYPT_COMMON_HASH_STATE,
        pOp: PCSYMRYPT_PARALLEL_HASH_OPERATION,
    ),
>;
pub type PSYMCRYPT_PARALLEL_APPEND_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pWork: *mut PSYMCRYPT_PARALLEL_HASH_SCRATCH_STATE,
        nPar: SIZE_T,
        nBytes: SIZE_T,
        pbSimdScratch: PBYTE,
        cbSimdScratch: SIZE_T,
    ),
>;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_PARALLEL_HASH {
    pub pHash: PCSYMCRYPT_HASH,
    pub parScratchFixed: UINT32,
    pub parResult1Func: PSYMCRYPT_PARALLEL_HASH_RESULT_FUNC,
    pub parResult2Func: PSYMCRYPT_PARALLEL_HASH_RESULT_FUNC,
    pub parResultDoneFunc: PSYMCRYPT_PARALLEL_HASH_RESULT_DONE_FUNC,
    pub parAppendFunc: PSYMCRYPT_PARALLEL_APPEND_FUNC,
}
impl Default for _SYMCRYPT_PARALLEL_HASH {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HMAC_MD5_EXPANDED_KEY {
    pub innerState: SYMCRYPT_MD5_CHAINING_STATE,
    pub outerState: SYMCRYPT_MD5_CHAINING_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_HMAC_MD5_EXPANDED_KEY = _SYMCRYPT_HMAC_MD5_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_MD5_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_MD5_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY = *const SYMCRYPT_HMAC_MD5_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HMAC_MD5_STATE {
    pub hash: SYMCRYPT_MD5_STATE,
    pub pKey: PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_HMAC_MD5_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_MD5_STATE = _SYMCRYPT_HMAC_MD5_STATE;
pub type PSYMCRYPT_HMAC_MD5_STATE = *mut _SYMCRYPT_HMAC_MD5_STATE;
pub type PCSYMCRYPT_HMAC_MD5_STATE = *const SYMCRYPT_HMAC_MD5_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HMAC_SHA1_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA1_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA1_CHAINING_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_HMAC_SHA1_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA1_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA1_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA1_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA1_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HMAC_SHA1_STATE {
    pub hash: SYMCRYPT_SHA1_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_HMAC_SHA1_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA1_STATE = _SYMCRYPT_HMAC_SHA1_STATE;
pub type PSYMCRYPT_HMAC_SHA1_STATE = *mut _SYMCRYPT_HMAC_SHA1_STATE;
pub type PCSYMCRYPT_HMAC_SHA1_STATE = *const SYMCRYPT_HMAC_SHA1_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HMAC_SHA224_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA256_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA256_CHAINING_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_HMAC_SHA224_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA224_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA224_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA224_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA224_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA224_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HMAC_SHA224_STATE {
    pub hash: SYMCRYPT_SHA224_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA224_EXPANDED_KEY,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_HMAC_SHA224_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA224_STATE = _SYMCRYPT_HMAC_SHA224_STATE;
pub type PSYMCRYPT_HMAC_SHA224_STATE = *mut _SYMCRYPT_HMAC_SHA224_STATE;
pub type PCSYMCRYPT_HMAC_SHA224_STATE = *const SYMCRYPT_HMAC_SHA224_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA256_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA256_CHAINING_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_HMAC_SHA256_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA256_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA256_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HMAC_SHA256_STATE {
    pub hash: SYMCRYPT_SHA256_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_HMAC_SHA256_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA256_STATE = _SYMCRYPT_HMAC_SHA256_STATE;
pub type PSYMCRYPT_HMAC_SHA256_STATE = *mut _SYMCRYPT_HMAC_SHA256_STATE;
pub type PCSYMCRYPT_HMAC_SHA256_STATE = *const SYMCRYPT_HMAC_SHA256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_HMAC_SHA384_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA384_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA384_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HMAC_SHA384_STATE {
    pub hash: SYMCRYPT_SHA384_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_HMAC_SHA384_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA384_STATE = _SYMCRYPT_HMAC_SHA384_STATE;
pub type PSYMCRYPT_HMAC_SHA384_STATE = *mut _SYMCRYPT_HMAC_SHA384_STATE;
pub type PCSYMCRYPT_HMAC_SHA384_STATE = *const SYMCRYPT_HMAC_SHA384_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HMAC_SHA512_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_HMAC_SHA512_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA512_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA512_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA512_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA512_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HMAC_SHA512_STATE {
    pub hash: SYMCRYPT_SHA512_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_HMAC_SHA512_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA512_STATE = _SYMCRYPT_HMAC_SHA512_STATE;
pub type PSYMCRYPT_HMAC_SHA512_STATE = *mut _SYMCRYPT_HMAC_SHA512_STATE;
pub type PCSYMCRYPT_HMAC_SHA512_STATE = *const SYMCRYPT_HMAC_SHA512_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HMAC_SHA512_224_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_HMAC_SHA512_224_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA512_224_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA512_224_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA512_224_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA512_224_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA512_224_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HMAC_SHA512_224_STATE {
    pub hash: SYMCRYPT_SHA512_224_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA512_224_EXPANDED_KEY,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_HMAC_SHA512_224_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA512_224_STATE = _SYMCRYPT_HMAC_SHA512_224_STATE;
pub type PSYMCRYPT_HMAC_SHA512_224_STATE = *mut _SYMCRYPT_HMAC_SHA512_224_STATE;
pub type PCSYMCRYPT_HMAC_SHA512_224_STATE = *const SYMCRYPT_HMAC_SHA512_224_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HMAC_SHA512_256_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub magic: SIZE_T,
}
pub type SYMCRYPT_HMAC_SHA512_256_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA512_256_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA512_256_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA512_256_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA512_256_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA512_256_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_HMAC_SHA512_256_STATE {
    pub hash: SYMCRYPT_SHA512_256_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA512_256_EXPANDED_KEY,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_HMAC_SHA512_256_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA512_256_STATE = _SYMCRYPT_HMAC_SHA512_256_STATE;
pub type PSYMCRYPT_HMAC_SHA512_256_STATE = *mut _SYMCRYPT_HMAC_SHA512_256_STATE;
pub type PCSYMCRYPT_HMAC_SHA512_256_STATE = *const SYMCRYPT_HMAC_SHA512_256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HMAC_EXPANDED_KEY {
    pub pHash: PCSYMCRYPT_HASH,
    pub __bindgen_padding_0: u64,
    pub innerState: SYMCRYPT_HASH_STATE,
    pub outerState: SYMCRYPT_HASH_STATE,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_HMAC_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_EXPANDED_KEY = _SYMCRYPT_HMAC_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_EXPANDED_KEY = *const SYMCRYPT_HMAC_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HMAC_STATE {
    pub pKey: PCSYMCRYPT_HMAC_EXPANDED_KEY,
    pub __bindgen_padding_0: u64,
    pub hash: SYMCRYPT_HASH_STATE,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_HMAC_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_STATE = _SYMCRYPT_HMAC_STATE;
pub type PSYMCRYPT_HMAC_STATE = *mut _SYMCRYPT_HMAC_STATE;
pub type PCSYMCRYPT_HMAC_STATE = *const SYMCRYPT_HMAC_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA3_224_EXPANDED_KEY {
    pub generic: SYMCRYPT_HMAC_EXPANDED_KEY,
}
impl Default for _SYMCRYPT_HMAC_SHA3_224_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA3_224_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA3_224_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA3_224_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA3_224_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA3_224_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA3_224_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA3_224_STATE {
    pub generic: SYMCRYPT_HMAC_STATE,
}
impl Default for _SYMCRYPT_HMAC_SHA3_224_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA3_224_STATE = _SYMCRYPT_HMAC_SHA3_224_STATE;
pub type PSYMCRYPT_HMAC_SHA3_224_STATE = *mut _SYMCRYPT_HMAC_SHA3_224_STATE;
pub type PCSYMCRYPT_HMAC_SHA3_224_STATE = *const SYMCRYPT_HMAC_SHA3_224_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY {
    pub generic: SYMCRYPT_HMAC_EXPANDED_KEY,
}
impl Default for _SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA3_256_STATE {
    pub generic: SYMCRYPT_HMAC_STATE,
}
impl Default for _SYMCRYPT_HMAC_SHA3_256_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA3_256_STATE = _SYMCRYPT_HMAC_SHA3_256_STATE;
pub type PSYMCRYPT_HMAC_SHA3_256_STATE = *mut _SYMCRYPT_HMAC_SHA3_256_STATE;
pub type PCSYMCRYPT_HMAC_SHA3_256_STATE = *const SYMCRYPT_HMAC_SHA3_256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY {
    pub generic: SYMCRYPT_HMAC_EXPANDED_KEY,
}
impl Default for _SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA3_384_STATE {
    pub generic: SYMCRYPT_HMAC_STATE,
}
impl Default for _SYMCRYPT_HMAC_SHA3_384_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA3_384_STATE = _SYMCRYPT_HMAC_SHA3_384_STATE;
pub type PSYMCRYPT_HMAC_SHA3_384_STATE = *mut _SYMCRYPT_HMAC_SHA3_384_STATE;
pub type PCSYMCRYPT_HMAC_SHA3_384_STATE = *const SYMCRYPT_HMAC_SHA3_384_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY {
    pub generic: SYMCRYPT_HMAC_EXPANDED_KEY,
}
impl Default for _SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA3_512_STATE {
    pub generic: SYMCRYPT_HMAC_STATE,
}
impl Default for _SYMCRYPT_HMAC_SHA3_512_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HMAC_SHA3_512_STATE = _SYMCRYPT_HMAC_SHA3_512_STATE;
pub type PSYMCRYPT_HMAC_SHA3_512_STATE = *mut _SYMCRYPT_HMAC_SHA3_512_STATE;
pub type PCSYMCRYPT_HMAC_SHA3_512_STATE = *const SYMCRYPT_HMAC_SHA3_512_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_AES_EXPANDED_KEY {
    pub RoundKey: [[[BYTE; 4usize]; 4usize]; 29usize],
    pub lastEncRoundKey: *mut [[BYTE; 4usize]; 4usize],
    pub lastDecRoundKey: *mut [[BYTE; 4usize]; 4usize],
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_AES_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_AES_EXPANDED_KEY = _SYMCRYPT_AES_EXPANDED_KEY;
pub type PSYMCRYPT_AES_EXPANDED_KEY = *mut _SYMCRYPT_AES_EXPANDED_KEY;
pub type PCSYMCRYPT_AES_EXPANDED_KEY = *const SYMCRYPT_AES_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_AES_CMAC_EXPANDED_KEY {
    pub aesKey: SYMCRYPT_AES_EXPANDED_KEY,
    pub K1: [BYTE; 16usize],
    pub K2: [BYTE; 16usize],
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_AES_CMAC_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_AES_CMAC_EXPANDED_KEY = _SYMCRYPT_AES_CMAC_EXPANDED_KEY;
pub type PSYMCRYPT_AES_CMAC_EXPANDED_KEY = *mut _SYMCRYPT_AES_CMAC_EXPANDED_KEY;
pub type PCSYMCRYPT_AES_CMAC_EXPANDED_KEY = *const SYMCRYPT_AES_CMAC_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_AES_CMAC_STATE {
    pub chain: [BYTE; 16usize],
    pub buf: [BYTE; 16usize],
    pub bytesInBuf: SIZE_T,
    pub pKey: PCSYMCRYPT_AES_CMAC_EXPANDED_KEY,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_AES_CMAC_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_AES_CMAC_STATE = _SYMCRYPT_AES_CMAC_STATE;
pub type PSYMCRYPT_AES_CMAC_STATE = *mut _SYMCRYPT_AES_CMAC_STATE;
pub type PCSYMCRYPT_AES_CMAC_STATE = *const SYMCRYPT_AES_CMAC_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_POLY1305_STATE {
    pub r: [UINT32; 4usize],
    pub s: [UINT32; 4usize],
    pub a: [UINT32; 5usize],
    pub bytesInBuffer: SIZE_T,
    pub buf: [BYTE; 16usize],
    pub magic: SIZE_T,
}
pub type SYMCRYPT_POLY1305_STATE = _SYMCRYPT_POLY1305_STATE;
pub type PSYMCRYPT_POLY1305_STATE = *mut _SYMCRYPT_POLY1305_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_XTS_AES_EXPANDED_KEY {
    pub key1: SYMCRYPT_AES_EXPANDED_KEY,
    pub key2: SYMCRYPT_AES_EXPANDED_KEY,
}
impl Default for _SYMCRYPT_XTS_AES_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_XTS_AES_EXPANDED_KEY = _SYMCRYPT_XTS_AES_EXPANDED_KEY;
pub type PSYMCRYPT_XTS_AES_EXPANDED_KEY = *mut _SYMCRYPT_XTS_AES_EXPANDED_KEY;
pub type PCSYMCRYPT_XTS_AES_EXPANDED_KEY = *const SYMCRYPT_XTS_AES_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_MAC_STATE {
    pub md5State: SYMCRYPT_HMAC_MD5_STATE,
    pub sha1State: SYMCRYPT_HMAC_SHA1_STATE,
    pub sha224State: SYMCRYPT_HMAC_SHA224_STATE,
    pub sha256State: SYMCRYPT_HMAC_SHA256_STATE,
    pub sha384State: SYMCRYPT_HMAC_SHA384_STATE,
    pub sha512State: SYMCRYPT_HMAC_SHA512_STATE,
    pub sha512_224State: SYMCRYPT_HMAC_SHA512_224_STATE,
    pub sha512_256State: SYMCRYPT_HMAC_SHA512_256_STATE,
    pub sha3_224State: SYMCRYPT_HMAC_SHA3_224_STATE,
    pub sha3_256State: SYMCRYPT_HMAC_SHA3_256_STATE,
    pub sha3_384State: SYMCRYPT_HMAC_SHA3_384_STATE,
    pub sha3_512State: SYMCRYPT_HMAC_SHA3_512_STATE,
    pub aescmacState: SYMCRYPT_AES_CMAC_STATE,
    pub kmac128State: SYMCRYPT_KMAC128_STATE,
    pub kmac256State: SYMCRYPT_KMAC256_STATE,
}
impl Default for _SYMCRYPT_MAC_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_MAC_STATE = _SYMCRYPT_MAC_STATE;
pub type PSYMCRYPT_MAC_STATE = *mut _SYMCRYPT_MAC_STATE;
pub type PCSYMCRYPT_MAC_STATE = *const SYMCRYPT_MAC_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_MAC_EXPANDED_KEY {
    pub md5Key: SYMCRYPT_HMAC_MD5_EXPANDED_KEY,
    pub sha1Key: SYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
    pub sha224Key: SYMCRYPT_HMAC_SHA224_EXPANDED_KEY,
    pub sha256Key: SYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
    pub sha384Key: SYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
    pub sha512Key: SYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
    pub sha512_224Key: SYMCRYPT_HMAC_SHA512_224_EXPANDED_KEY,
    pub sha512_256Key: SYMCRYPT_HMAC_SHA512_256_EXPANDED_KEY,
    pub sha3_224Key: SYMCRYPT_HMAC_SHA3_224_EXPANDED_KEY,
    pub sha3_256Key: SYMCRYPT_HMAC_SHA3_256_EXPANDED_KEY,
    pub sha3_384Key: SYMCRYPT_HMAC_SHA3_384_EXPANDED_KEY,
    pub sha3_512Key: SYMCRYPT_HMAC_SHA3_512_EXPANDED_KEY,
    pub aescmacKey: SYMCRYPT_AES_CMAC_EXPANDED_KEY,
    pub kmac128Key: SYMCRYPT_KMAC128_EXPANDED_KEY,
    pub kmac256Key: SYMCRYPT_KMAC256_EXPANDED_KEY,
}
impl Default for _SYMCRYPT_MAC_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_MAC_EXPANDED_KEY = _SYMCRYPT_MAC_EXPANDED_KEY;
pub type PSYMCRYPT_MAC_EXPANDED_KEY = *mut _SYMCRYPT_MAC_EXPANDED_KEY;
pub type PCSYMCRYPT_MAC_EXPANDED_KEY = *const SYMCRYPT_MAC_EXPANDED_KEY;
pub type PSYMCRYPT_MAC_EXPAND_KEY = ::std::option::Option<
    unsafe extern "C" fn(pExpandedKey: PVOID, pbKey: PCBYTE, cbKey: SIZE_T) -> SYMCRYPT_ERROR,
>;
pub type PSYMCRYPT_MAC_INIT =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pExpandedKey: PCVOID)>;
pub type PSYMCRYPT_MAC_APPEND =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbData: PCBYTE, cbData: SIZE_T)>;
pub type PSYMCRYPT_MAC_RESULT =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbResult: PVOID)>;
pub type PSYMCRYPT_MAC_RESULT_EX =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbResult: PVOID, cbResult: SIZE_T)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_MAC {
    pub expandKeyFunc: PSYMCRYPT_MAC_EXPAND_KEY,
    pub initFunc: PSYMCRYPT_MAC_INIT,
    pub appendFunc: PSYMCRYPT_MAC_APPEND,
    pub resultFunc: PSYMCRYPT_MAC_RESULT,
    pub expandedKeySize: SIZE_T,
    pub stateSize: SIZE_T,
    pub resultSize: SIZE_T,
    pub ppHashAlgorithm: *const PCSYMCRYPT_HASH,
    pub outerChainingStateOffset: UINT32,
}
impl Default for _SYMCRYPT_MAC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_MAC = _SYMCRYPT_MAC;
pub type PSYMCRYPT_MAC = *mut _SYMCRYPT_MAC;
pub type PCSYMCRYPT_MAC = *const SYMCRYPT_MAC;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_3DES_EXPANDED_KEY {
    pub roundKey: [[[UINT32; 2usize]; 16usize]; 3usize],
    pub magic: SIZE_T,
}
pub type SYMCRYPT_3DES_EXPANDED_KEY = _SYMCRYPT_3DES_EXPANDED_KEY;
pub type PSYMCRYPT_3DES_EXPANDED_KEY = *mut _SYMCRYPT_3DES_EXPANDED_KEY;
pub type PCSYMCRYPT_3DES_EXPANDED_KEY = *const SYMCRYPT_3DES_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_DES_EXPANDED_KEY {
    pub threeDes: SYMCRYPT_3DES_EXPANDED_KEY,
}
pub type SYMCRYPT_DES_EXPANDED_KEY = _SYMCRYPT_DES_EXPANDED_KEY;
pub type PSYMCRYPT_DES_EXPANDED_KEY = *mut _SYMCRYPT_DES_EXPANDED_KEY;
pub type PCSYMCRYPT_DES_EXPANDED_KEY = *const SYMCRYPT_DES_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_DESX_EXPANDED_KEY {
    pub desKey: SYMCRYPT_DES_EXPANDED_KEY,
    pub inputWhitening: [BYTE; 8usize],
    pub outputWhitening: [BYTE; 8usize],
}
pub type SYMCRYPT_DESX_EXPANDED_KEY = _SYMCRYPT_DESX_EXPANDED_KEY;
pub type PSYMCRYPT_DESX_EXPANDED_KEY = *mut _SYMCRYPT_DESX_EXPANDED_KEY;
pub type PCSYMCRYPT_DESX_EXPANDED_KEY = *const SYMCRYPT_DESX_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_RC2_EXPANDED_KEY {
    pub K: [UINT16; 64usize],
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_RC2_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_RC2_EXPANDED_KEY = _SYMCRYPT_RC2_EXPANDED_KEY;
pub type PSYMCRYPT_RC2_EXPANDED_KEY = *mut _SYMCRYPT_RC2_EXPANDED_KEY;
pub type PCSYMCRYPT_RC2_EXPANDED_KEY = *const SYMCRYPT_RC2_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_CCM_STATE {
    pub pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
    pub pExpandedKey: PCVOID,
    pub cbData: UINT64,
    pub cbTag: SIZE_T,
    pub cbNonce: SIZE_T,
    pub cbCounter: SIZE_T,
    pub bytesProcessed: UINT64,
    pub bytesInMacBlock: SIZE_T,
    pub counterBlock: [BYTE; 16usize],
    pub macBlock: [BYTE; 16usize],
    pub keystreamBlock: [BYTE; 16usize],
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_CCM_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_CCM_STATE = _SYMCRYPT_CCM_STATE;
pub type PSYMCRYPT_CCM_STATE = *mut _SYMCRYPT_CCM_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS {
    pub aes: SYMCRYPT_AES_EXPANDED_KEY,
}
impl Default for _SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS = _SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type poly8_t = ::std::os::raw::c_uchar;
pub type poly16_t = ::std::os::raw::c_ushort;
pub type poly32_t = ::std::os::raw::c_uint;
pub type poly64_t = ::std::os::raw::c_ulonglong;
pub type float32_t = f32;
pub type float64_t = f64;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __n32 {
    pub n32_u32: [::std::os::raw::c_uint; 1usize],
    pub n32_u16: [::std::os::raw::c_ushort; 2usize],
    pub n32_u8: [::std::os::raw::c_uchar; 4usize],
    pub n32_i32: [::std::os::raw::c_int; 1usize],
    pub n32_i16: [::std::os::raw::c_short; 2usize],
    pub n32_i8: [::std::os::raw::c_char; 4usize],
    pub n32_p32: [poly32_t; 1usize],
    pub n32_p16: [poly16_t; 2usize],
    pub n32_p8: [poly8_t; 4usize],
    pub n32_f32: [f32; 1usize],
}
impl Default for __n32 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __n16 {
    pub n16_u16: [::std::os::raw::c_ushort; 1usize],
    pub n16_u8: [::std::os::raw::c_uchar; 2usize],
    pub n16_i16: [::std::os::raw::c_short; 1usize],
    pub n16_i8: [::std::os::raw::c_char; 2usize],
    pub n16_p16: [poly16_t; 1usize],
    pub n16_p8: [poly8_t; 2usize],
}
impl Default for __n16 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __n8 {
    pub n8_u8: [::std::os::raw::c_uchar; 1usize],
    pub n8_i8: [::std::os::raw::c_char; 1usize],
    pub n8_p8: [poly8_t; 1usize],
}
impl Default for __n8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __n64 {
    pub n64_u64: [::std::os::raw::c_ulonglong; 1usize],
    pub n64_u32: [::std::os::raw::c_uint; 2usize],
    pub n64_u16: [::std::os::raw::c_ushort; 4usize],
    pub n64_u8: [::std::os::raw::c_uchar; 8usize],
    pub n64_i64: [::std::os::raw::c_longlong; 1usize],
    pub n64_i32: [::std::os::raw::c_int; 2usize],
    pub n64_i16: [::std::os::raw::c_short; 4usize],
    pub n64_i8: [::std::os::raw::c_char; 8usize],
    pub n64_p64: [poly64_t; 1usize],
    pub n64_p32: [poly32_t; 2usize],
    pub n64_p16: [poly16_t; 4usize],
    pub n64_p8: [poly8_t; 8usize],
    pub n64_f32: [f32; 2usize],
    pub n64_f64: [f64; 1usize],
}
impl Default for __n64 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union __n128 {
    pub n128_u64: [::std::os::raw::c_ulonglong; 2usize],
    pub n128_u32: [::std::os::raw::c_uint; 4usize],
    pub n128_u16: [::std::os::raw::c_ushort; 8usize],
    pub n128_u8: [::std::os::raw::c_uchar; 16usize],
    pub n128_i64: [::std::os::raw::c_longlong; 2usize],
    pub n128_i32: [::std::os::raw::c_int; 4usize],
    pub n128_i16: [::std::os::raw::c_short; 8usize],
    pub n128_i8: [::std::os::raw::c_char; 16usize],
    pub n128_p64: [poly64_t; 2usize],
    pub n128_p32: [poly32_t; 4usize],
    pub n128_p16: [poly16_t; 8usize],
    pub n128_p8: [poly8_t; 16usize],
    pub n128_f32: [f32; 4usize],
    pub n128_f64: [f64; 2usize],
    pub s: __n128__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __n128__bindgen_ty_1 {
    pub low64: __n64,
    pub high64: __n64,
}
impl Default for __n128__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __n128 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __n32x2 {
    pub val: [__n32; 2usize],
}
impl Default for __n32x2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __n64x2 {
    pub val: [__n64; 2usize],
}
impl Default for __n64x2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __n64x3 {
    pub val: [__n64; 3usize],
}
impl Default for __n64x3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __n64x4 {
    pub val: [__n64; 4usize],
}
impl Default for __n64x4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct __n128x2 {
    pub val: [__n128; 2usize],
}
impl Default for __n128x2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct __n128x3 {
    pub val: [__n128; 3usize],
}
impl Default for __n128x3 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct __n128x4 {
    pub val: [__n128; 4usize],
}
impl Default for __n128x4 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type float32x1_t = __n32;
pub type float32x1x2_t = __n32x2;
pub type float32x2_t = __n64;
pub type float32x2x2_t = __n64x2;
pub type float32x2x3_t = __n64x3;
pub type float32x2x4_t = __n64x4;
pub type float64x1_t = __n64;
pub type float64x1x2_t = __n64x2;
pub type float64x1x3_t = __n64x3;
pub type float64x1x4_t = __n64x4;
pub type int8x8_t = __n64;
pub type int8x8x2_t = __n64x2;
pub type int8x8x3_t = __n64x3;
pub type int8x8x4_t = __n64x4;
pub type int16x4_t = __n64;
pub type int16x4x2_t = __n64x2;
pub type int16x4x3_t = __n64x3;
pub type int16x4x4_t = __n64x4;
pub type int32x2_t = __n64;
pub type int32x2x2_t = __n64x2;
pub type int32x2x3_t = __n64x3;
pub type int32x2x4_t = __n64x4;
pub type int64x1_t = __n64;
pub type int64x1x2_t = __n64x2;
pub type int64x1x3_t = __n64x3;
pub type int64x1x4_t = __n64x4;
pub type poly8x8_t = __n64;
pub type poly8x8x2_t = __n64x2;
pub type poly8x8x3_t = __n64x3;
pub type poly8x8x4_t = __n64x4;
pub type poly16x4_t = __n64;
pub type poly16x4x2_t = __n64x2;
pub type poly16x4x3_t = __n64x3;
pub type poly16x4x4_t = __n64x4;
pub type poly64x1_t = __n64;
pub type poly64x1x2_t = __n64x2;
pub type poly64x1x3_t = __n64x3;
pub type poly64x1x4_t = __n64x4;
pub type uint8x8_t = __n64;
pub type uint8x8x2_t = __n64x2;
pub type uint8x8x3_t = __n64x3;
pub type uint8x8x4_t = __n64x4;
pub type uint16x4_t = __n64;
pub type uint16x4x2_t = __n64x2;
pub type uint16x4x3_t = __n64x3;
pub type uint16x4x4_t = __n64x4;
pub type uint32x2_t = __n64;
pub type uint32x2x2_t = __n64x2;
pub type uint32x2x3_t = __n64x3;
pub type uint32x2x4_t = __n64x4;
pub type uint64x1_t = __n64;
pub type uint64x1x2_t = __n64x2;
pub type uint64x1x3_t = __n64x3;
pub type uint64x1x4_t = __n64x4;
pub type float32x4_t = __n128;
pub type float32x4x2_t = __n128x2;
pub type float32x4x3_t = __n128x3;
pub type float32x4x4_t = __n128x4;
pub type float64x2_t = __n128;
pub type float64x2x2_t = __n128x2;
pub type float64x2x3_t = __n128x3;
pub type float64x2x4_t = __n128x4;
pub type int8x16_t = __n128;
pub type int8x16x2_t = __n128x2;
pub type int8x16x3_t = __n128x3;
pub type int8x16x4_t = __n128x4;
pub type int16x8_t = __n128;
pub type int16x8x2_t = __n128x2;
pub type int16x8x3_t = __n128x3;
pub type int16x8x4_t = __n128x4;
pub type int32x4_t = __n128;
pub type int32x4x2_t = __n128x2;
pub type int32x4x3_t = __n128x3;
pub type int32x4x4_t = __n128x4;
pub type int64x2_t = __n128;
pub type int64x2x2_t = __n128x2;
pub type int64x2x3_t = __n128x3;
pub type int64x2x4_t = __n128x4;
pub type poly8x16_t = __n128;
pub type poly8x16x2_t = __n128x2;
pub type poly8x16x3_t = __n128x3;
pub type poly8x16x4_t = __n128x4;
pub type poly16x8_t = __n128;
pub type poly16x8x2_t = __n128x2;
pub type poly16x8x3_t = __n128x3;
pub type poly16x8x4_t = __n128x4;
pub type poly64x2_t = __n128;
pub type poly64x2x2_t = __n128x2;
pub type poly64x2x3_t = __n128x3;
pub type poly64x2x4_t = __n128x4;
pub type uint8x16_t = __n128;
pub type uint8x16x2_t = __n128x2;
pub type uint8x16x3_t = __n128x3;
pub type uint8x16x4_t = __n128x4;
pub type uint16x8_t = __n128;
pub type uint16x8x2_t = __n128x2;
pub type uint16x8x3_t = __n128x3;
pub type uint16x8x4_t = __n128x4;
pub type uint32x4_t = __n128;
pub type uint32x4x2_t = __n128x2;
pub type uint32x4x3_t = __n128x3;
pub type uint32x4x4_t = __n128x4;
pub type uint64x2_t = __n128;
pub type uint64x2x2_t = __n128x2;
pub type uint64x2x3_t = __n128x3;
pub type uint64x2x4_t = __n128x4;
pub type float16x4_t = __n64;
pub type float16x4x2_t = __n64x2;
pub type float16x4x3_t = __n64x3;
pub type float16x4x4_t = __n64x4;
pub type float16x8_t = __n128;
pub type float16x8x2_t = __n128x2;
pub type float16x8x3_t = __n128x3;
pub type float16x8x4_t = __n128x4;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_GF128_ELEMENT {
    pub ull: [UINT64; 2usize],
    pub n128: __n128,
    pub ul: [UINT32; 4usize],
}
impl Default for _SYMCRYPT_GF128_ELEMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_GF128_ELEMENT = _SYMCRYPT_GF128_ELEMENT;
pub type PSYMCRYPT_GF128_ELEMENT = *mut _SYMCRYPT_GF128_ELEMENT;
pub type PCSYMCRYPT_GF128_ELEMENT = *const SYMCRYPT_GF128_ELEMENT;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_GHASH_EXPANDED_KEY {
    pub table: [SYMCRYPT_GF128_ELEMENT; 128usize],
}
impl Default for _SYMCRYPT_GHASH_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_GHASH_EXPANDED_KEY = _SYMCRYPT_GHASH_EXPANDED_KEY;
pub type PSYMCRYPT_GHASH_EXPANDED_KEY = *mut _SYMCRYPT_GHASH_EXPANDED_KEY;
pub type PCSYMCRYPT_GHASH_EXPANDED_KEY = *const SYMCRYPT_GHASH_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_GCM_EXPANDED_KEY {
    pub ghashKey: SYMCRYPT_GHASH_EXPANDED_KEY,
    pub pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
    pub __bindgen_padding_0: u64,
    pub blockcipherKey: SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS,
    pub cbKey: SIZE_T,
    pub abKey: [BYTE; 32usize],
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_GCM_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_GCM_EXPANDED_KEY = _SYMCRYPT_GCM_EXPANDED_KEY;
pub type PSYMCRYPT_GCM_EXPANDED_KEY = *mut _SYMCRYPT_GCM_EXPANDED_KEY;
pub type PCSYMCRYPT_GCM_EXPANDED_KEY = *const SYMCRYPT_GCM_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_GCM_STATE {
    pub pKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
    pub cbData: UINT64,
    pub cbAuthData: UINT64,
    pub bytesInMacBlock: SIZE_T,
    pub ghashState: SYMCRYPT_GF128_ELEMENT,
    pub counterBlock: [BYTE; 16usize],
    pub macBlock: [BYTE; 16usize],
    pub keystreamBlock: [BYTE; 16usize],
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_GCM_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_GCM_STATE = _SYMCRYPT_GCM_STATE;
pub type PSYMCRYPT_GCM_STATE = *mut _SYMCRYPT_GCM_STATE;
pub type PCSYMCRYPT_GCM_STATE = *const SYMCRYPT_GCM_STATE;
pub type PSYMCRYPT_BLOCKCIPHER_EXPAND_KEY = ::std::option::Option<
    unsafe extern "C" fn(pExpandedKey: PVOID, pbKey: PCBYTE, cbKey: SIZE_T) -> SYMCRYPT_ERROR,
>;
pub type PSYMCRYPT_BLOCKCIPHER_CRYPT =
    ::std::option::Option<unsafe extern "C" fn(pExpandedKey: PCVOID, pbSrc: PCBYTE, pbDst: PBYTE)>;
pub type PSYMCRYPT_BLOCKCIPHER_CRYPT_ECB = ::std::option::Option<
    unsafe extern "C" fn(pExpandedKey: PCVOID, pbSrc: PCBYTE, pbDst: PBYTE, cbData: SIZE_T),
>;
pub type PSYMCRYPT_BLOCKCIPHER_CRYPT_MODE = ::std::option::Option<
    unsafe extern "C" fn(
        pExpandedKey: PCVOID,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    ),
>;
pub type PSYMCRYPT_BLOCKCIPHER_MAC_MODE = ::std::option::Option<
    unsafe extern "C" fn(
        pExpandedKey: PCVOID,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        cbData: SIZE_T,
    ),
>;
pub type PSYMCRYPT_BLOCKCIPHER_AEADPART_MODE = ::std::option::Option<
    unsafe extern "C" fn(pState: PVOID, pbSrc: PCBYTE, pbDst: PBYTE, cbData: SIZE_T),
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_BLOCKCIPHER {
    pub expandKeyFunc: PSYMCRYPT_BLOCKCIPHER_EXPAND_KEY,
    pub encryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT,
    pub decryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT,
    pub ecbEncryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT_ECB,
    pub ecbDecryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT_ECB,
    pub cbcEncryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT_MODE,
    pub cbcDecryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT_MODE,
    pub cbcMacFunc: PSYMCRYPT_BLOCKCIPHER_MAC_MODE,
    pub ctrMsb64Func: PSYMCRYPT_BLOCKCIPHER_CRYPT_MODE,
    pub gcmEncryptPartFunc: PSYMCRYPT_BLOCKCIPHER_AEADPART_MODE,
    pub gcmDecryptPartFunc: PSYMCRYPT_BLOCKCIPHER_AEADPART_MODE,
    pub blockSize: SIZE_T,
    pub expandedKeySize: SIZE_T,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SESSION_REPLAY_STATE {
    pub replayMask: UINT64,
    pub messageNumber: UINT64,
}
pub type SYMCRYPT_SESSION_REPLAY_STATE = _SYMCRYPT_SESSION_REPLAY_STATE;
pub type PSYMCRYPT_SESSION_REPLAY_STATE = *mut _SYMCRYPT_SESSION_REPLAY_STATE;
pub type PCSYMCRYPT_SESSION_REPLAY_STATE = *const SYMCRYPT_SESSION_REPLAY_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SESSION {
    pub replayState: SYMCRYPT_SESSION_REPLAY_STATE,
    pub senderId: UINT32,
    pub flags: UINT32,
    pub pMutex: PVOID,
}
impl Default for _SYMCRYPT_SESSION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SESSION = _SYMCRYPT_SESSION;
pub type PSYMCRYPT_SESSION = *mut _SYMCRYPT_SESSION;
pub type SYMCRYPT_RC4_S_TYPE = BYTE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_RC4_STATE {
    pub S: [SYMCRYPT_RC4_S_TYPE; 256usize],
    pub i: BYTE,
    pub j: BYTE,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_RC4_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_RC4_STATE = _SYMCRYPT_RC4_STATE;
pub type PSYMCRYPT_RC4_STATE = *mut _SYMCRYPT_RC4_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_CHACHA20_STATE {
    pub key: [UINT32; 8usize],
    pub nonce: [UINT32; 3usize],
    pub offset: UINT64,
    pub keystreamBufferValid: BOOLEAN,
    pub keystream: [BYTE; 64usize],
}
impl Default for _SYMCRYPT_CHACHA20_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_CHACHA20_STATE = _SYMCRYPT_CHACHA20_STATE;
pub type PSYMCRYPT_CHACHA20_STATE = *mut _SYMCRYPT_CHACHA20_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_RNG_AES_STATE {
    pub keyAndV: [BYTE; 48usize],
    pub previousBlock: [BYTE; 16usize],
    pub requestCounter: UINT64,
    pub fips140_2Check: BOOLEAN,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_RNG_AES_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_RNG_AES_STATE = _SYMCRYPT_RNG_AES_STATE;
pub type PSYMCRYPT_RNG_AES_STATE = *mut _SYMCRYPT_RNG_AES_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_RNG_AES_FIPS140_2_STATE {
    pub rng: SYMCRYPT_RNG_AES_STATE,
}
impl Default for _SYMCRYPT_RNG_AES_FIPS140_2_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_RNG_AES_FIPS140_2_STATE = _SYMCRYPT_RNG_AES_FIPS140_2_STATE;
pub type PSYMCRYPT_RNG_AES_FIPS140_2_STATE = *mut _SYMCRYPT_RNG_AES_FIPS140_2_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_MARVIN32_EXPANDED_SEED {
    pub s: [UINT32; 2usize],
    pub magic: SIZE_T,
}
pub type SYMCRYPT_MARVIN32_EXPANDED_SEED = _SYMCRYPT_MARVIN32_EXPANDED_SEED;
pub type PSYMCRYPT_MARVIN32_EXPANDED_SEED = *mut _SYMCRYPT_MARVIN32_EXPANDED_SEED;
pub type PCSYMCRYPT_MARVIN32_EXPANDED_SEED = *const SYMCRYPT_MARVIN32_EXPANDED_SEED;
pub type SYMCRYPT_MARVIN32_CHAINING_STATE = SYMCRYPT_MARVIN32_EXPANDED_SEED;
pub type PSYMCRYPT_MARVIN32_CHAINING_STATE = *mut SYMCRYPT_MARVIN32_EXPANDED_SEED;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_MARVIN32_STATE {
    pub buffer: [BYTE; 8usize],
    pub __bindgen_padding_0: u64,
    pub chain: SYMCRYPT_MARVIN32_CHAINING_STATE,
    pub pSeed: PCSYMCRYPT_MARVIN32_EXPANDED_SEED,
    pub dataLength: UINT32,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_MARVIN32_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_MARVIN32_STATE = _SYMCRYPT_MARVIN32_STATE;
pub type PSYMCRYPT_MARVIN32_STATE = *mut _SYMCRYPT_MARVIN32_STATE;
pub type PCSYMCRYPT_MARVIN32_STATE = *const SYMCRYPT_MARVIN32_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_PBKDF2_EXPANDED_KEY {
    pub macKey: SYMCRYPT_MAC_EXPANDED_KEY,
    pub macAlg: PCSYMCRYPT_MAC,
}
impl Default for _SYMCRYPT_PBKDF2_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_PBKDF2_EXPANDED_KEY = _SYMCRYPT_PBKDF2_EXPANDED_KEY;
pub type PSYMCRYPT_PBKDF2_EXPANDED_KEY = *mut _SYMCRYPT_PBKDF2_EXPANDED_KEY;
pub type PCSYMCRYPT_PBKDF2_EXPANDED_KEY = *const SYMCRYPT_PBKDF2_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_SP800_108_EXPANDED_KEY {
    pub macKey: SYMCRYPT_MAC_EXPANDED_KEY,
    pub macAlg: PCSYMCRYPT_MAC,
}
impl Default for _SYMCRYPT_SP800_108_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SP800_108_EXPANDED_KEY = _SYMCRYPT_SP800_108_EXPANDED_KEY;
pub type PSYMCRYPT_SP800_108_EXPANDED_KEY = *mut _SYMCRYPT_SP800_108_EXPANDED_KEY;
pub type PCSYMCRYPT_SP800_108_EXPANDED_KEY = *const SYMCRYPT_SP800_108_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_TLSPRF1_1_EXPANDED_KEY {
    pub macMd5Key: SYMCRYPT_HMAC_MD5_EXPANDED_KEY,
    pub macSha1Key: SYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
}
pub type SYMCRYPT_TLSPRF1_1_EXPANDED_KEY = _SYMCRYPT_TLSPRF1_1_EXPANDED_KEY;
pub type PSYMCRYPT_TLSPRF1_1_EXPANDED_KEY = *mut _SYMCRYPT_TLSPRF1_1_EXPANDED_KEY;
pub type PCSYMCRYPT_TLSPRF1_1_EXPANDED_KEY = *const SYMCRYPT_TLSPRF1_1_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY {
    pub macKey: SYMCRYPT_MAC_EXPANDED_KEY,
    pub macAlg: PCSYMCRYPT_MAC,
}
impl Default for _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_TLSPRF1_2_EXPANDED_KEY = _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY;
pub type PSYMCRYPT_TLSPRF1_2_EXPANDED_KEY = *mut _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY;
pub type PCSYMCRYPT_TLSPRF1_2_EXPANDED_KEY = *const SYMCRYPT_TLSPRF1_2_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_SSHKDF_EXPANDED_KEY {
    pub pHashFunc: PCSYMCRYPT_HASH,
    pub __bindgen_padding_0: u64,
    pub hashState: SYMCRYPT_HASH_STATE,
}
impl Default for _SYMCRYPT_SSHKDF_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SSHKDF_EXPANDED_KEY = _SYMCRYPT_SSHKDF_EXPANDED_KEY;
pub type PSYMCRYPT_SSHKDF_EXPANDED_KEY = *mut _SYMCRYPT_SSHKDF_EXPANDED_KEY;
pub type PCSYMCRYPT_SSHKDF_EXPANDED_KEY = *const SYMCRYPT_SSHKDF_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_SRTPKDF_EXPANDED_KEY {
    pub aesExpandedKey: SYMCRYPT_AES_EXPANDED_KEY,
}
impl Default for _SYMCRYPT_SRTPKDF_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SRTPKDF_EXPANDED_KEY = _SYMCRYPT_SRTPKDF_EXPANDED_KEY;
pub type PSYMCRYPT_SRTPKDF_EXPANDED_KEY = *mut _SYMCRYPT_SRTPKDF_EXPANDED_KEY;
pub type PCSYMCRYPT_SRTPKDF_EXPANDED_KEY = *const SYMCRYPT_SRTPKDF_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HKDF_EXPANDED_KEY {
    pub macKey: SYMCRYPT_MAC_EXPANDED_KEY,
    pub macAlg: PCSYMCRYPT_MAC,
}
impl Default for _SYMCRYPT_HKDF_EXPANDED_KEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_HKDF_EXPANDED_KEY = _SYMCRYPT_HKDF_EXPANDED_KEY;
pub type PSYMCRYPT_HKDF_EXPANDED_KEY = *mut _SYMCRYPT_HKDF_EXPANDED_KEY;
pub type PCSYMCRYPT_HKDF_EXPANDED_KEY = *const SYMCRYPT_HKDF_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_SSKDF_MAC_EXPANDED_SALT {
    pub macKey: SYMCRYPT_MAC_EXPANDED_KEY,
    pub macAlg: PCSYMCRYPT_MAC,
}
impl Default for _SYMCRYPT_SSKDF_MAC_EXPANDED_SALT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_SSKDF_MAC_EXPANDED_SALT = _SYMCRYPT_SSKDF_MAC_EXPANDED_SALT;
pub type PSYMCRYPT_SSKDF_MAC_EXPANDED_SALT = *mut _SYMCRYPT_SSKDF_MAC_EXPANDED_SALT;
pub type PCSYMCRYPT_SSKDF_MAC_EXPANDED_SALT = *const SYMCRYPT_SSKDF_MAC_EXPANDED_SALT;
pub type SYMCRYPT_INT = _SYMCRYPT_INT;
pub type PSYMCRYPT_INT = *mut SYMCRYPT_INT;
pub type PCSYMCRYPT_INT = *const SYMCRYPT_INT;
pub type SYMCRYPT_DIVISOR = _SYMCRYPT_DIVISOR;
pub type PSYMCRYPT_DIVISOR = *mut SYMCRYPT_DIVISOR;
pub type PCSYMCRYPT_DIVISOR = *const SYMCRYPT_DIVISOR;
pub type SYMCRYPT_MODULUS = _SYMCRYPT_MODULUS;
pub type PSYMCRYPT_MODULUS = *mut SYMCRYPT_MODULUS;
pub type PCSYMCRYPT_MODULUS = *const SYMCRYPT_MODULUS;
pub type SYMCRYPT_MODELEMENT = _SYMCRYPT_MODELEMENT;
pub type PSYMCRYPT_MODELEMENT = *mut SYMCRYPT_MODELEMENT;
pub type PCSYMCRYPT_MODELEMENT = *const SYMCRYPT_MODELEMENT;
pub type SYMCRYPT_ECPOINT = _SYMCRYPT_ECPOINT;
pub type PSYMCRYPT_ECPOINT = *mut SYMCRYPT_ECPOINT;
pub type PCSYMCRYPT_ECPOINT = *const SYMCRYPT_ECPOINT;
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_INT {
    pub type_: UINT32,
    pub nDigits: UINT32,
    pub cbSize: UINT32,
    pub magic: SIZE_T,
    pub __bindgen_padding_0: u64,
    pub ti: _SYMCRYPT_INT__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_INT__bindgen_ty_1 {
    pub fdef: _SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1 {
    pub uint32: [UINT32; 1usize],
}
impl Default for _SYMCRYPT_INT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SYMCRYPT_INT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_DIVISOR {
    pub type_: UINT32,
    pub nDigits: UINT32,
    pub cbSize: UINT32,
    pub nBits: UINT32,
    pub magic: SIZE_T,
    pub td: _SYMCRYPT_DIVISOR__bindgen_ty_1,
    pub Int: SYMCRYPT_INT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_DIVISOR__bindgen_ty_1 {
    pub fdef: _SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1 {
    pub W: UINT64,
}
impl Default for _SYMCRYPT_DIVISOR__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SYMCRYPT_DIVISOR {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_MODULUS {
    pub type_: UINT32,
    pub nDigits: UINT32,
    pub cbSize: UINT32,
    pub flags: UINT32,
    pub cbModElement: UINT32,
    pub inv64: UINT64,
    pub magic: SIZE_T,
    pub tm: _SYMCRYPT_MODULUS__bindgen_ty_1,
    pub __bindgen_padding_0: [u64; 2usize],
    pub Divisor: SYMCRYPT_DIVISOR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_MODULUS__bindgen_ty_1 {
    pub montgomery: _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1,
    pub pseudoMersenne: _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1 {
    pub Rsqr: PCUINT32,
}
impl Default for _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2 {
    pub k: UINT32,
}
impl Default for _SYMCRYPT_MODULUS__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SYMCRYPT_MODULUS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_MODELEMENT {
    pub d: _SYMCRYPT_MODELEMENT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_MODELEMENT__bindgen_ty_1 {
    pub uint32: [UINT32; 1usize],
}
impl Default for _SYMCRYPT_MODELEMENT__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SYMCRYPT_MODELEMENT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MLKEMKEY {
    _unused: [u8; 0],
}
pub type SYMCRYPT_MLKEMKEY = _SYMCRYPT_MLKEMKEY;
pub type PSYMCRYPT_MLKEMKEY = *mut SYMCRYPT_MLKEMKEY;
pub type PCSYMCRYPT_MLKEMKEY = *const SYMCRYPT_MLKEMKEY;
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_RSAKEY {
    pub fAlgorithmInfo: UINT32,
    pub cbTotalSize: UINT32,
    pub hasPrivateKey: BOOLEAN,
    pub nSetBitsOfModulus: UINT32,
    pub nBitsOfModulus: UINT32,
    pub nDigitsOfModulus: UINT32,
    pub nPubExp: UINT32,
    pub nPrimes: UINT32,
    pub nBitsOfPrimes: [UINT32; 2usize],
    pub nDigitsOfPrimes: [UINT32; 2usize],
    pub nMaxDigitsOfPrimes: UINT32,
    pub au64PubExp: [UINT64; 1usize],
    pub pbPrimes: [PBYTE; 2usize],
    pub pbCrtInverses: [PBYTE; 2usize],
    pub pbPrivExps: [PBYTE; 1usize],
    pub pbCrtPrivExps: [PBYTE; 2usize],
    pub pmModulus: PSYMCRYPT_MODULUS,
    pub pmPrimes: [PSYMCRYPT_MODULUS; 2usize],
    pub peCrtInverses: [PSYMCRYPT_MODELEMENT; 2usize],
    pub piPrivExps: [PSYMCRYPT_INT; 1usize],
    pub piCrtPrivExps: [PSYMCRYPT_INT; 2usize],
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_RSAKEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_RSAKEY = _SYMCRYPT_RSAKEY;
pub type PSYMCRYPT_RSAKEY = *mut SYMCRYPT_RSAKEY;
pub type PCSYMCRYPT_RSAKEY = *const SYMCRYPT_RSAKEY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_TRIALDIVISION_PRIME {
    pub invMod2e64: UINT64,
    pub compareLimit: UINT64,
}
pub type SYMCRYPT_TRIALDIVISION_PRIME = _SYMCRYPT_TRIALDIVISION_PRIME;
pub type PSYMCRYPT_TRIALDIVISION_PRIME = *mut _SYMCRYPT_TRIALDIVISION_PRIME;
pub type PCSYMCRYPT_TRIALDIVISION_PRIME = *const SYMCRYPT_TRIALDIVISION_PRIME;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_TRIALDIVISION_GROUP {
    pub nPrimes: UINT32,
    pub factor: [UINT32; 9usize],
}
pub type SYMCRYPT_TRIALDIVISION_GROUP = _SYMCRYPT_TRIALDIVISION_GROUP;
pub type PSYMCRYPT_TRIALDIVISION_GROUP = *mut _SYMCRYPT_TRIALDIVISION_GROUP;
pub type PCSYMCRYPT_TRIALDIVISION_GROUP = *const SYMCRYPT_TRIALDIVISION_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_TRIALDIVISION_CONTEXT {
    pub nBytesAlloc: SIZE_T,
    pub maxTrialPrime: UINT32,
    pub pGroupList: PSYMCRYPT_TRIALDIVISION_GROUP,
    pub pPrimeList: PSYMCRYPT_TRIALDIVISION_PRIME,
    pub pPrimes: PUINT32,
    pub Primes3_5_17: [SYMCRYPT_TRIALDIVISION_PRIME; 3usize],
}
impl Default for _SYMCRYPT_TRIALDIVISION_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_TRIALDIVISION_CONTEXT = _SYMCRYPT_TRIALDIVISION_CONTEXT;
pub type PSYMCRYPT_TRIALDIVISION_CONTEXT = *mut _SYMCRYPT_TRIALDIVISION_CONTEXT;
pub type PCSYMCRYPT_TRIALDIVISION_CONTEXT = *const SYMCRYPT_TRIALDIVISION_CONTEXT;
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_DLGROUP {
    pub cbTotalSize: UINT32,
    pub fHasPrimeQ: BOOLEAN,
    pub nBitsOfP: UINT32,
    pub cbPrimeP: UINT32,
    pub nDigitsOfP: UINT32,
    pub nMaxBitsOfP: UINT32,
    pub nBitsOfQ: UINT32,
    pub cbPrimeQ: UINT32,
    pub nDigitsOfQ: UINT32,
    pub nMaxBitsOfQ: UINT32,
    pub isSafePrimeGroup: BOOLEAN,
    pub nMinBitsPriv: UINT32,
    pub nDefaultBitsPriv: UINT32,
    pub nBitsOfSeed: UINT32,
    pub cbSeed: UINT32,
    pub eFipsStandard: SYMCRYPT_DLGROUP_FIPS,
    pub pHashAlgorithm: PCSYMCRYPT_HASH,
    pub dwGenCounter: UINT32,
    pub bIndexGenG: BYTE,
    pub pbQ: PBYTE,
    pub pmP: PSYMCRYPT_MODULUS,
    pub pmQ: PSYMCRYPT_MODULUS,
    pub peG: PSYMCRYPT_MODELEMENT,
    pub pbSeed: PBYTE,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_DLGROUP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_DLGROUP = _SYMCRYPT_DLGROUP;
pub type PSYMCRYPT_DLGROUP = *mut SYMCRYPT_DLGROUP;
pub type PCSYMCRYPT_DLGROUP = *const SYMCRYPT_DLGROUP;
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_DLKEY {
    pub fAlgorithmInfo: UINT32,
    pub fHasPrivateKey: BOOLEAN,
    pub fPrivateModQ: BOOLEAN,
    pub nBitsPriv: UINT32,
    pub pDlgroup: PCSYMCRYPT_DLGROUP,
    pub pbPrivate: PBYTE,
    pub pePublicKey: PSYMCRYPT_MODELEMENT,
    pub piPrivateKey: PSYMCRYPT_INT,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_DLKEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_DLKEY = _SYMCRYPT_DLKEY;
pub type PSYMCRYPT_DLKEY = *mut SYMCRYPT_DLKEY;
pub type PCSYMCRYPT_DLKEY = *const SYMCRYPT_DLKEY;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_INVALID:
    _SYMCRYPT_ECPOINT_COORDINATES = 0;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_SINGLE:
    _SYMCRYPT_ECPOINT_COORDINATES = 17;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_AFFINE:
    _SYMCRYPT_ECPOINT_COORDINATES = 34;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_PROJECTIVE:
    _SYMCRYPT_ECPOINT_COORDINATES = 51;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_JACOBIAN:
    _SYMCRYPT_ECPOINT_COORDINATES = 67;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_EXTENDED_PROJECTIVE:
    _SYMCRYPT_ECPOINT_COORDINATES = 84;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_SINGLE_PROJECTIVE:
    _SYMCRYPT_ECPOINT_COORDINATES = 98;
pub type _SYMCRYPT_ECPOINT_COORDINATES = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_ECPOINT_COORDINATES as SYMCRYPT_ECPOINT_COORDINATES;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_ECURVE_INFO_PRECOMP {
    pub window: UINT32,
    pub nPrecompPoints: UINT32,
    pub nRecodedDigits: UINT32,
    pub poPrecompPoints: [PSYMCRYPT_ECPOINT; 64usize],
}
impl Default for _SYMCRYPT_ECURVE_INFO_PRECOMP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_ECURVE_INFO_PRECOMP = _SYMCRYPT_ECURVE_INFO_PRECOMP;
pub const _SYMCRYPT_INTERNAL_ECURVE_TYPE_SYMCRYPT_INTERNAL_ECURVE_TYPE_SHORT_WEIERSTRASS:
    _SYMCRYPT_INTERNAL_ECURVE_TYPE = 1;
pub const _SYMCRYPT_INTERNAL_ECURVE_TYPE_SYMCRYPT_INTERNAL_ECURVE_TYPE_TWISTED_EDWARDS:
    _SYMCRYPT_INTERNAL_ECURVE_TYPE = 2;
pub const _SYMCRYPT_INTERNAL_ECURVE_TYPE_SYMCRYPT_INTERNAL_ECURVE_TYPE_MONTGOMERY:
    _SYMCRYPT_INTERNAL_ECURVE_TYPE = 3;
pub const _SYMCRYPT_INTERNAL_ECURVE_TYPE_SYMCRYPT_INTERNAL_ECURVE_TYPE_SHORT_WEIERSTRASS_AM3:
    _SYMCRYPT_INTERNAL_ECURVE_TYPE = 4;
pub type _SYMCRYPT_INTERNAL_ECURVE_TYPE = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_INTERNAL_ECURVE_TYPE as SYMCRYPT_INTERNAL_ECURVE_TYPE;
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_ECURVE {
    pub version: UINT32,
    pub type_: SYMCRYPT_INTERNAL_ECURVE_TYPE,
    pub eCoordinates: SYMCRYPT_ECPOINT_COORDINATES,
    pub FModBitsize: UINT32,
    pub FModDigits: UINT32,
    pub FModBytesize: UINT32,
    pub GOrdBitsize: UINT32,
    pub GOrdDigits: UINT32,
    pub GOrdBytesize: UINT32,
    pub cbModElement: UINT32,
    pub cbAlloc: UINT32,
    pub cbScratchCommon: UINT32,
    pub cbScratchScalar: UINT32,
    pub cbScratchScalarMulti: UINT32,
    pub cbScratchGetSetValue: UINT32,
    pub cbScratchEckey: UINT32,
    pub coFactorPower: UINT32,
    pub PrivateKeyDefaultFormat: UINT32,
    pub HighBitRestrictionNumOfBits: UINT32,
    pub HighBitRestrictionPosition: UINT32,
    pub HighBitRestrictionValue: UINT32,
    pub info: _SYMCRYPT_ECURVE__bindgen_ty_1,
    pub FMod: PSYMCRYPT_MODULUS,
    pub GOrd: PSYMCRYPT_MODULUS,
    pub A: PSYMCRYPT_MODELEMENT,
    pub B: PSYMCRYPT_MODELEMENT,
    pub G: PSYMCRYPT_ECPOINT,
    pub H: PSYMCRYPT_INT,
    pub magic: SIZE_T,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_ECURVE__bindgen_ty_1 {
    pub sw: SYMCRYPT_ECURVE_INFO_PRECOMP,
}
impl Default for _SYMCRYPT_ECURVE__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for _SYMCRYPT_ECURVE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_ECURVE = _SYMCRYPT_ECURVE;
pub type PSYMCRYPT_ECURVE = *mut SYMCRYPT_ECURVE;
pub type PCSYMCRYPT_ECURVE = *const SYMCRYPT_ECURVE;
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_ECPOINT {
    pub normalized: BOOLEAN,
    pub pCurve: PCSYMCRYPT_ECURVE,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_ECPOINT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_ECKEY {
    pub fAlgorithmInfo: UINT32,
    pub hasPrivateKey: BOOLEAN,
    pub pCurve: PCSYMCRYPT_ECURVE,
    pub poPublicKey: PSYMCRYPT_ECPOINT,
    pub piPrivateKey: PSYMCRYPT_INT,
    pub magic: SIZE_T,
}
impl Default for _SYMCRYPT_ECKEY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_ECKEY = _SYMCRYPT_ECKEY;
pub type PSYMCRYPT_ECKEY = *mut SYMCRYPT_ECKEY;
pub type PCSYMCRYPT_ECKEY = *const SYMCRYPT_ECKEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_802_11_SAE_CUSTOM_STATE {
    pub pCurve: PSYMCRYPT_ECURVE,
    pub macAlgorithm: PCSYMCRYPT_MAC,
    pub peRand: PSYMCRYPT_MODELEMENT,
    pub peMask: PSYMCRYPT_MODELEMENT,
    pub poPWE: PSYMCRYPT_ECPOINT,
    pub counter: BYTE,
}
impl Default for _SYMCRYPT_802_11_SAE_CUSTOM_STATE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_XMSS_PARAMS {
    pub hash: PCSYMCRYPT_HASH,
    pub id: UINT32,
    pub cbHashOutput: UINT32,
    pub nWinternitzWidth: UINT32,
    pub nTotalTreeHeight: UINT32,
    pub nLayers: UINT32,
    pub cbPrefix: UINT32,
    pub len1: UINT32,
    pub len2: UINT32,
    pub len: UINT32,
    pub nLayerHeight: UINT32,
    pub cbIdx: UINT32,
    pub nLeftShift32: UINT32,
    pub Reserved: [BYTE; 16usize],
}
impl Default for _SYMCRYPT_XMSS_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_XMSS_PARAMS = _SYMCRYPT_XMSS_PARAMS;
pub type PSYMCRYPT_XMSS_PARAMS = *mut SYMCRYPT_XMSS_PARAMS;
pub type PCSYMCRYPT_XMSS_PARAMS = *const SYMCRYPT_XMSS_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_XMSS_KEY {
    _unused: [u8; 0],
}
pub type SYMCRYPT_XMSS_KEY = _SYMCRYPT_XMSS_KEY;
pub type PSYMCRYPT_XMSS_KEY = *mut SYMCRYPT_XMSS_KEY;
pub type PCSYMCRYPT_XMSS_KEY = *const SYMCRYPT_XMSS_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_LMS_PARAMS {
    pub lmsAlgID: UINT32,
    pub lmsOtsAlgID: UINT32,
    pub pLmsHashFunction: PCSYMCRYPT_HASH,
    pub nTreeHeight: UINT32,
    pub cbHashOutput: UINT32,
    pub nWinternitzChainWidth: UINT32,
    pub nByteStringCount: UINT32,
    pub nChecksumLShiftBits: UINT32,
}
impl Default for _SYMCRYPT_LMS_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_LMS_PARAMS = _SYMCRYPT_LMS_PARAMS;
pub type PSYMCRYPT_LMS_PARAMS = *mut SYMCRYPT_LMS_PARAMS;
pub type PCSYMCRYPT_LMS_PARAMS = *const SYMCRYPT_LMS_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_LMS_KEY {
    _unused: [u8; 0],
}
pub type SYMCRYPT_LMS_KEY = _SYMCRYPT_LMS_KEY;
pub type PSYMCRYPT_LMS_KEY = *mut SYMCRYPT_LMS_KEY;
pub type PCSYMCRYPT_LMS_KEY = *const SYMCRYPT_LMS_KEY;
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_NONE:
    _SYMCRYPT_SELFTEST_ALGORITHM = 0;
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_STARTUP:
    _SYMCRYPT_SELFTEST_ALGORITHM = 1;
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_DSA:
    _SYMCRYPT_SELFTEST_ALGORITHM = 2;
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_ECDSA:
    _SYMCRYPT_SELFTEST_ALGORITHM = 4;
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_RSA:
    _SYMCRYPT_SELFTEST_ALGORITHM = 8;
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_DH:
    _SYMCRYPT_SELFTEST_ALGORITHM = 16;
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_ECDH:
    _SYMCRYPT_SELFTEST_ALGORITHM = 32;
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_MLKEM:
    _SYMCRYPT_SELFTEST_ALGORITHM = 64;
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_XMSS:
    _SYMCRYPT_SELFTEST_ALGORITHM = 128;
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_LMS:
    _SYMCRYPT_SELFTEST_ALGORITHM = 256;
pub type _SYMCRYPT_SELFTEST_ALGORITHM = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_SELFTEST_ALGORITHM as SYMCRYPT_SELFTEST_ALGORITHM;
pub const _SYMCRYPT_NUMBER_FORMAT_SYMCRYPT_NUMBER_FORMAT_LSB_FIRST: _SYMCRYPT_NUMBER_FORMAT = 1;
pub const _SYMCRYPT_NUMBER_FORMAT_SYMCRYPT_NUMBER_FORMAT_MSB_FIRST: _SYMCRYPT_NUMBER_FORMAT = 2;
pub type _SYMCRYPT_NUMBER_FORMAT = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_NUMBER_FORMAT as SYMCRYPT_NUMBER_FORMAT;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_RSA_PARAMS {
    pub version: UINT32,
    pub nBitsOfModulus: UINT32,
    pub nPrimes: UINT32,
    pub nPubExp: UINT32,
}
pub type SYMCRYPT_RSA_PARAMS = _SYMCRYPT_RSA_PARAMS;
pub type PSYMCRYPT_RSA_PARAMS = *mut _SYMCRYPT_RSA_PARAMS;
pub type PCSYMCRYPT_RSA_PARAMS = *const SYMCRYPT_RSA_PARAMS;
pub const _SYMCRYPT_ECURVE_GEN_ALG_ID_SYMCRYPT_ECURVE_GEN_ALG_ID_NULL: _SYMCRYPT_ECURVE_GEN_ALG_ID =
    0;
pub type _SYMCRYPT_ECURVE_GEN_ALG_ID = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_ECURVE_GEN_ALG_ID as SYMCRYPT_ECURVE_GEN_ALG_ID;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION {
    pub PrivateKeyDefaultFormat: UINT32,
    pub HighBitRestrictionNumOfBits: UINT32,
    pub HighBitRestrictionPosition: UINT32,
    pub HighBitRestrictionValue: UINT32,
}
pub type SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION = _SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION;
pub type PSYMCRYPT_ECURVE_PARAMS_V2_EXTENSION = *mut _SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION;
pub type PCSYMCRYPT_ECURVE_PARAMS_V2_EXTENSION = *const SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION;
pub const _SYMCRYPT_ECKEY_PRIVATE_FORMAT_SYMCRYPT_ECKEY_PRIVATE_FORMAT_NULL:
    _SYMCRYPT_ECKEY_PRIVATE_FORMAT = 0;
pub const _SYMCRYPT_ECKEY_PRIVATE_FORMAT_SYMCRYPT_ECKEY_PRIVATE_FORMAT_CANONICAL:
    _SYMCRYPT_ECKEY_PRIVATE_FORMAT = 1;
pub const _SYMCRYPT_ECKEY_PRIVATE_FORMAT_SYMCRYPT_ECKEY_PRIVATE_FORMAT_DIVH:
    _SYMCRYPT_ECKEY_PRIVATE_FORMAT = 2;
pub const _SYMCRYPT_ECKEY_PRIVATE_FORMAT_SYMCRYPT_ECKEY_PRIVATE_FORMAT_DIVH_TIMESH:
    _SYMCRYPT_ECKEY_PRIVATE_FORMAT = 3;
pub type _SYMCRYPT_ECKEY_PRIVATE_FORMAT = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_ECKEY_PRIVATE_FORMAT as SYMCRYPT_ECKEY_PRIVATE_FORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_ECURVE_PARAMS {
    pub version: UINT32,
    pub type_: SYMCRYPT_ECURVE_TYPE,
    pub algId: SYMCRYPT_ECURVE_GEN_ALG_ID,
    pub cbFieldLength: UINT32,
    pub cbSubgroupOrder: UINT32,
    pub cbCofactor: UINT32,
    pub cbSeed: UINT32,
}
impl Default for _SYMCRYPT_ECURVE_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_ECURVE_PARAMS = _SYMCRYPT_ECURVE_PARAMS;
pub type PSYMCRYPT_ECURVE_PARAMS = *mut _SYMCRYPT_ECURVE_PARAMS;
pub type PCSYMCRYPT_ECURVE_PARAMS = *const SYMCRYPT_ECURVE_PARAMS;
pub const _SYMCRYPT_ECPOINT_FORMAT_SYMCRYPT_ECPOINT_FORMAT_X: _SYMCRYPT_ECPOINT_FORMAT = 1;
pub const _SYMCRYPT_ECPOINT_FORMAT_SYMCRYPT_ECPOINT_FORMAT_XY: _SYMCRYPT_ECPOINT_FORMAT = 2;
pub type _SYMCRYPT_ECPOINT_FORMAT = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_ECPOINT_FORMAT as SYMCRYPT_ECPOINT_FORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_OID {
    pub cbOID: UINT32,
    pub pbOID: PCBYTE,
}
impl Default for _SYMCRYPT_OID {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type SYMCRYPT_OID = _SYMCRYPT_OID;
pub type PSYMCRYPT_OID = *mut _SYMCRYPT_OID;
pub type PCSYMCRYPT_OID = *const SYMCRYPT_OID;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHA2_10_256: _SYMCRYPT_XMSS_ALGID = 1;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHA2_16_256: _SYMCRYPT_XMSS_ALGID = 2;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHA2_20_256: _SYMCRYPT_XMSS_ALGID = 3;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHA2_10_512: _SYMCRYPT_XMSS_ALGID = 4;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHA2_16_512: _SYMCRYPT_XMSS_ALGID = 5;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHA2_20_512: _SYMCRYPT_XMSS_ALGID = 6;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHAKE_10_256: _SYMCRYPT_XMSS_ALGID = 7;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHAKE_16_256: _SYMCRYPT_XMSS_ALGID = 8;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHAKE_20_256: _SYMCRYPT_XMSS_ALGID = 9;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHAKE_10_512: _SYMCRYPT_XMSS_ALGID = 10;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHAKE_16_512: _SYMCRYPT_XMSS_ALGID = 11;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHAKE_20_512: _SYMCRYPT_XMSS_ALGID = 12;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHA2_10_192: _SYMCRYPT_XMSS_ALGID = 13;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHA2_16_192: _SYMCRYPT_XMSS_ALGID = 14;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHA2_20_192: _SYMCRYPT_XMSS_ALGID = 15;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHAKE256_10_256: _SYMCRYPT_XMSS_ALGID = 16;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHAKE256_16_256: _SYMCRYPT_XMSS_ALGID = 17;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHAKE256_20_256: _SYMCRYPT_XMSS_ALGID = 18;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHAKE256_10_192: _SYMCRYPT_XMSS_ALGID = 19;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHAKE256_16_192: _SYMCRYPT_XMSS_ALGID = 20;
pub const _SYMCRYPT_XMSS_ALGID_SYMCRYPT_XMSS_SHAKE256_20_192: _SYMCRYPT_XMSS_ALGID = 21;
pub type _SYMCRYPT_XMSS_ALGID = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_XMSS_ALGID as SYMCRYPT_XMSS_ALGID;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_20_2_256: _SYMCRYPT_XMSSMT_ALGID = 1;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_20_4_256: _SYMCRYPT_XMSSMT_ALGID = 2;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_40_2_256: _SYMCRYPT_XMSSMT_ALGID = 3;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_40_4_256: _SYMCRYPT_XMSSMT_ALGID = 4;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_40_8_256: _SYMCRYPT_XMSSMT_ALGID = 5;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_60_3_256: _SYMCRYPT_XMSSMT_ALGID = 6;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_60_6_256: _SYMCRYPT_XMSSMT_ALGID = 7;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_60_12_256: _SYMCRYPT_XMSSMT_ALGID = 8;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_20_2_512: _SYMCRYPT_XMSSMT_ALGID = 9;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_20_4_512: _SYMCRYPT_XMSSMT_ALGID = 10;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_40_2_512: _SYMCRYPT_XMSSMT_ALGID = 11;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_40_4_512: _SYMCRYPT_XMSSMT_ALGID = 12;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_40_8_512: _SYMCRYPT_XMSSMT_ALGID = 13;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_60_3_512: _SYMCRYPT_XMSSMT_ALGID = 14;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_60_6_512: _SYMCRYPT_XMSSMT_ALGID = 15;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_60_12_512: _SYMCRYPT_XMSSMT_ALGID = 16;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE_20_2_256: _SYMCRYPT_XMSSMT_ALGID = 17;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE_20_4_256: _SYMCRYPT_XMSSMT_ALGID = 18;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE_40_2_256: _SYMCRYPT_XMSSMT_ALGID = 19;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE_40_4_256: _SYMCRYPT_XMSSMT_ALGID = 20;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE_40_8_256: _SYMCRYPT_XMSSMT_ALGID = 21;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE_60_3_256: _SYMCRYPT_XMSSMT_ALGID = 22;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE_60_6_256: _SYMCRYPT_XMSSMT_ALGID = 23;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE_60_12_256: _SYMCRYPT_XMSSMT_ALGID = 24;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE_20_2_512: _SYMCRYPT_XMSSMT_ALGID = 25;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE_20_4_512: _SYMCRYPT_XMSSMT_ALGID = 26;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE_40_2_512: _SYMCRYPT_XMSSMT_ALGID = 27;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE_40_4_512: _SYMCRYPT_XMSSMT_ALGID = 28;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE_40_8_512: _SYMCRYPT_XMSSMT_ALGID = 29;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE_60_3_512: _SYMCRYPT_XMSSMT_ALGID = 30;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE_60_6_512: _SYMCRYPT_XMSSMT_ALGID = 31;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE_60_12_512: _SYMCRYPT_XMSSMT_ALGID = 32;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_20_2_192: _SYMCRYPT_XMSSMT_ALGID = 33;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_20_4_192: _SYMCRYPT_XMSSMT_ALGID = 34;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_40_2_192: _SYMCRYPT_XMSSMT_ALGID = 35;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_40_4_192: _SYMCRYPT_XMSSMT_ALGID = 36;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_40_8_192: _SYMCRYPT_XMSSMT_ALGID = 37;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_60_3_192: _SYMCRYPT_XMSSMT_ALGID = 38;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_60_6_192: _SYMCRYPT_XMSSMT_ALGID = 39;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHA2_60_12_192: _SYMCRYPT_XMSSMT_ALGID = 40;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE256_20_2_256: _SYMCRYPT_XMSSMT_ALGID = 41;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE256_20_4_256: _SYMCRYPT_XMSSMT_ALGID = 42;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE256_40_2_256: _SYMCRYPT_XMSSMT_ALGID = 43;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE256_40_4_256: _SYMCRYPT_XMSSMT_ALGID = 44;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE256_40_8_256: _SYMCRYPT_XMSSMT_ALGID = 45;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE256_60_3_256: _SYMCRYPT_XMSSMT_ALGID = 46;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE256_60_6_256: _SYMCRYPT_XMSSMT_ALGID = 47;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE256_60_12_256: _SYMCRYPT_XMSSMT_ALGID = 48;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE256_20_2_192: _SYMCRYPT_XMSSMT_ALGID = 49;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE256_20_4_192: _SYMCRYPT_XMSSMT_ALGID = 50;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE256_40_2_192: _SYMCRYPT_XMSSMT_ALGID = 51;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE256_40_4_192: _SYMCRYPT_XMSSMT_ALGID = 52;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE256_40_8_192: _SYMCRYPT_XMSSMT_ALGID = 53;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE256_60_3_192: _SYMCRYPT_XMSSMT_ALGID = 54;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE256_60_6_192: _SYMCRYPT_XMSSMT_ALGID = 55;
pub const _SYMCRYPT_XMSSMT_ALGID_SYMCRYPT_XMSSMT_SHAKE256_60_12_192: _SYMCRYPT_XMSSMT_ALGID = 56;
pub type _SYMCRYPT_XMSSMT_ALGID = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_XMSSMT_ALGID as SYMCRYPT_XMSSMT_ALGID;
pub const _SYMCRYPT_XMSSKEY_TYPE_SYMCRYPT_XMSSKEY_TYPE_NONE: _SYMCRYPT_XMSSKEY_TYPE = 0;
pub const _SYMCRYPT_XMSSKEY_TYPE_SYMCRYPT_XMSSKEY_TYPE_PUBLIC: _SYMCRYPT_XMSSKEY_TYPE = 1;
pub const _SYMCRYPT_XMSSKEY_TYPE_SYMCRYPT_XMSSKEY_TYPE_PRIVATE: _SYMCRYPT_XMSSKEY_TYPE = 2;
pub type _SYMCRYPT_XMSSKEY_TYPE = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_XMSSKEY_TYPE as SYMCRYPT_XMSSKEY_TYPE;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHA256_M32_H5: _SYMCRYPT_LMS_ALGID = 5;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHA256_M32_H10: _SYMCRYPT_LMS_ALGID = 6;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHA256_M32_H15: _SYMCRYPT_LMS_ALGID = 7;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHA256_M32_H20: _SYMCRYPT_LMS_ALGID = 8;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHA256_M32_H25: _SYMCRYPT_LMS_ALGID = 9;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHA256_M24_H5: _SYMCRYPT_LMS_ALGID = 10;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHA256_M24_H10: _SYMCRYPT_LMS_ALGID = 11;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHA256_M24_H15: _SYMCRYPT_LMS_ALGID = 12;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHA256_M24_H20: _SYMCRYPT_LMS_ALGID = 13;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHA256_M24_H25: _SYMCRYPT_LMS_ALGID = 14;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHAKE_M32_H5: _SYMCRYPT_LMS_ALGID = 15;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHAKE_M32_H10: _SYMCRYPT_LMS_ALGID = 16;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHAKE_M32_H15: _SYMCRYPT_LMS_ALGID = 17;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHAKE_M32_H20: _SYMCRYPT_LMS_ALGID = 18;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHAKE_M32_H25: _SYMCRYPT_LMS_ALGID = 19;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHAKE_M24_H5: _SYMCRYPT_LMS_ALGID = 20;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHAKE_M24_H10: _SYMCRYPT_LMS_ALGID = 21;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHAKE_M24_H15: _SYMCRYPT_LMS_ALGID = 22;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHAKE_M24_H20: _SYMCRYPT_LMS_ALGID = 23;
pub const _SYMCRYPT_LMS_ALGID_SYMCRYPT_LMS_SHAKE_M24_H25: _SYMCRYPT_LMS_ALGID = 24;
pub type _SYMCRYPT_LMS_ALGID = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_LMS_ALGID as SYMCRYPT_LMS_ALGID;
pub const _SYMCRYPT_LMS_OTS_ALGID_SYMCRYPT_LMS_OTS_SHA256_N32_W1: _SYMCRYPT_LMS_OTS_ALGID = 1;
pub const _SYMCRYPT_LMS_OTS_ALGID_SYMCRYPT_LMS_OTS_SHA256_N32_W2: _SYMCRYPT_LMS_OTS_ALGID = 2;
pub const _SYMCRYPT_LMS_OTS_ALGID_SYMCRYPT_LMS_OTS_SHA256_N32_W4: _SYMCRYPT_LMS_OTS_ALGID = 3;
pub const _SYMCRYPT_LMS_OTS_ALGID_SYMCRYPT_LMS_OTS_SHA256_N32_W8: _SYMCRYPT_LMS_OTS_ALGID = 4;
pub const _SYMCRYPT_LMS_OTS_ALGID_SYMCRYPT_LMS_OTS_SHA256_N24_W1: _SYMCRYPT_LMS_OTS_ALGID = 5;
pub const _SYMCRYPT_LMS_OTS_ALGID_SYMCRYPT_LMS_OTS_SHA256_N24_W2: _SYMCRYPT_LMS_OTS_ALGID = 6;
pub const _SYMCRYPT_LMS_OTS_ALGID_SYMCRYPT_LMS_OTS_SHA256_N24_W4: _SYMCRYPT_LMS_OTS_ALGID = 7;
pub const _SYMCRYPT_LMS_OTS_ALGID_SYMCRYPT_LMS_OTS_SHA256_N24_W8: _SYMCRYPT_LMS_OTS_ALGID = 8;
pub const _SYMCRYPT_LMS_OTS_ALGID_SYMCRYPT_LMS_OTS_SHAKE_N32_W1: _SYMCRYPT_LMS_OTS_ALGID = 9;
pub const _SYMCRYPT_LMS_OTS_ALGID_SYMCRYPT_LMS_OTS_SHAKE_N32_W2: _SYMCRYPT_LMS_OTS_ALGID = 10;
pub const _SYMCRYPT_LMS_OTS_ALGID_SYMCRYPT_LMS_OTS_SHAKE_N32_W4: _SYMCRYPT_LMS_OTS_ALGID = 11;
pub const _SYMCRYPT_LMS_OTS_ALGID_SYMCRYPT_LMS_OTS_SHAKE_N32_W8: _SYMCRYPT_LMS_OTS_ALGID = 12;
pub const _SYMCRYPT_LMS_OTS_ALGID_SYMCRYPT_LMS_OTS_SHAKE_N24_W1: _SYMCRYPT_LMS_OTS_ALGID = 13;
pub const _SYMCRYPT_LMS_OTS_ALGID_SYMCRYPT_LMS_OTS_SHAKE_N24_W2: _SYMCRYPT_LMS_OTS_ALGID = 14;
pub const _SYMCRYPT_LMS_OTS_ALGID_SYMCRYPT_LMS_OTS_SHAKE_N24_W4: _SYMCRYPT_LMS_OTS_ALGID = 15;
pub const _SYMCRYPT_LMS_OTS_ALGID_SYMCRYPT_LMS_OTS_SHAKE_N24_W8: _SYMCRYPT_LMS_OTS_ALGID = 16;
pub type _SYMCRYPT_LMS_OTS_ALGID = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_LMS_OTS_ALGID as SYMCRYPT_LMS_OTS_ALGID;
pub const _SYMCRYPT_LMSKEY_TYPE_SYMCRYPT_LMSKEY_TYPE_NONE: _SYMCRYPT_LMSKEY_TYPE = 0;
pub const _SYMCRYPT_LMSKEY_TYPE_SYMCRYPT_LMSKEY_TYPE_PUBLIC: _SYMCRYPT_LMSKEY_TYPE = 1;
pub const _SYMCRYPT_LMSKEY_TYPE_SYMCRYPT_LMSKEY_TYPE_PRIVATE: _SYMCRYPT_LMSKEY_TYPE = 2;
pub type _SYMCRYPT_LMSKEY_TYPE = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_LMSKEY_TYPE as SYMCRYPT_LMSKEY_TYPE;
pub const _SYMCRYPT_MLKEMKEY_FORMAT_SYMCRYPT_MLKEMKEY_FORMAT_NULL: _SYMCRYPT_MLKEMKEY_FORMAT = 0;
pub const _SYMCRYPT_MLKEMKEY_FORMAT_SYMCRYPT_MLKEMKEY_FORMAT_PRIVATE_SEED:
    _SYMCRYPT_MLKEMKEY_FORMAT = 1;
pub const _SYMCRYPT_MLKEMKEY_FORMAT_SYMCRYPT_MLKEMKEY_FORMAT_DECAPSULATION_KEY:
    _SYMCRYPT_MLKEMKEY_FORMAT = 2;
pub const _SYMCRYPT_MLKEMKEY_FORMAT_SYMCRYPT_MLKEMKEY_FORMAT_ENCAPSULATION_KEY:
    _SYMCRYPT_MLKEMKEY_FORMAT = 3;
pub type _SYMCRYPT_MLKEMKEY_FORMAT = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_MLKEMKEY_FORMAT as SYMCRYPT_MLKEMKEY_FORMAT;
pub const _SYMCRYPT_MLKEM_PARAMS_SYMCRYPT_MLKEM_PARAMS_NULL: _SYMCRYPT_MLKEM_PARAMS = 0;
pub const _SYMCRYPT_MLKEM_PARAMS_SYMCRYPT_MLKEM_PARAMS_MLKEM512: _SYMCRYPT_MLKEM_PARAMS = 1;
pub const _SYMCRYPT_MLKEM_PARAMS_SYMCRYPT_MLKEM_PARAMS_MLKEM768: _SYMCRYPT_MLKEM_PARAMS = 2;
pub const _SYMCRYPT_MLKEM_PARAMS_SYMCRYPT_MLKEM_PARAMS_MLKEM1024: _SYMCRYPT_MLKEM_PARAMS = 3;
pub type _SYMCRYPT_MLKEM_PARAMS = ::std::os::raw::c_int;
pub use self::_SYMCRYPT_MLKEM_PARAMS as SYMCRYPT_MLKEM_PARAMS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _SYMCRYPT_UINT32_MAP {
    pub from: UINT32,
    pub to: UINT32,
}
pub type SYMCRYPT_UINT32_MAP = _SYMCRYPT_UINT32_MAP;
pub type PSYMCRYPT_UINT32_MAP = *mut _SYMCRYPT_UINT32_MAP;
pub type PCSYMCRYPT_UINT32_MAP = *const SYMCRYPT_UINT32_MAP;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
